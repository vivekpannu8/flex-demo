{"ast":null,"code":"import _asyncToGenerator from \"/home/karthiwaters/flex-demo/node_modules/@babel/runtime/helpers/esm/asyncToGenerator.js\";\nimport { EventEmitter, forwardRef } from '@angular/core';\nimport { Clipboard, Tooltip } from '@grapecity/wijmo';\nimport { WjFlexGrid, wjFlexGridMeta } from '@grapecity/wijmo.angular2.grid';\nimport { AllowSorting, CellRange, CellRangeEventArgs, SelectionMode } from '@grapecity/wijmo.grid';\nimport { v4 as uuidv4 } from 'uuid';\nimport { TableFieldDataType } from 'app/model/types/table-field-data-type.enum';\nimport { TableHelperService } from './table-helper.service';\nimport * as i0 from \"@angular/core\";\nexport let WatFlexGridComponent = /*#__PURE__*/(() => {\n  class WatFlexGridComponent extends WjFlexGrid {\n    colToSelect = 0;\n    rowToSelect = 0;\n    fromOnGridInit = false;\n    restoreSelectionMode = null;\n    observer;\n    tableId;\n    fields;\n    disableDefaultSelect = false;\n    pastingInProgress = false;\n    disableTableCellDict;\n    enableCopyDown = false;\n    copyDownColumns;\n    enableCopyRight = false;\n    copyDownEnded = new EventEmitter();\n    copyRightEnded = new EventEmitter();\n    get rowSelected() {\n      if (this.selectionMode === SelectionMode.Row) {\n        return true;\n      }\n      if (this.selectionMode === SelectionMode.Cell || this.containsFocus() || this.selectedRanges.length !== 1) {\n        return false;\n      }\n      const range = this.selectedRanges[0];\n      return range.row === range.row2 && range.col === 0 && range.col2 === this.columns.length - 1;\n    }\n    errorTooltip;\n    columnHeaderTooltip;\n    tableHelperFunctions;\n    // errorData used for tracking errors on editable table rows\n    errorData =\n    // dictionary\n    {};\n    get hasErrors() {\n      const errorsExist = Object.values(this.errorData).some(record => record.error);\n      return errorsExist;\n    }\n    created() {\n      this.fields = null;\n      this.showMarquee = true; // for placing a border around groups of selected cells\n      this.anchorCursor = true;\n      this.tableId = uuidv4();\n      this.tableHelperFunctions = new TableHelperService().for(this.tableId, this);\n      // error tooltip\n      this.errorTooltip = new Tooltip();\n      this.errorTooltip.isContentHtml = true;\n      this.errorTooltip.cssClass = \"wj-error-tip\";\n      // column header tooltip\n      this.columnHeaderTooltip = new Tooltip();\n      this.columnHeaderTooltip.isContentHtml = true;\n      this.columnHeaderTooltip.cssClass = \"wj-header-tip top\";\n      this.loadedRows.addHandler(this.loadedRowsHandler);\n      this.selectionChanged.addHandler(this.selectionChangedHandler);\n      //override to pasting behavior\n      this.pasted.addHandler(this.afterPasteHandler);\n      this.pasting.addHandler(this.beforePasteHandler);\n      this.copying.addHandler(this.beforeCopyHandler);\n      // base class handler name needs to be unique - assures this handler and other\n      // cellEditEnded handlers in components that use this component also get called\n      this.beginningEdit.addHandler(this.onBeginEditBase.bind(this));\n      this.cellEditEnded.addHandler(this.onCellEditEndedBase.bind(this));\n      this.allowSorting = AllowSorting.None;\n      // Set the minimum size of the row headers to 60px so that users can't\n      // resize the column to smaller than 60px.\n      this.rowHeaders.columns.minSize = 60;\n      // Prevent the row headers from being resized and causing other columns to be hidden\n      this.rowHeaders.columns[0].allowResizing = false;\n      this.errorTip.isContentHtml = true;\n      this.refreshOnEdit = true;\n      this.hostElement.addEventListener('keydown', e => {\n        if ((e.code === \"KeyD\" || e.code === \"KeyR\") && e.ctrlKey) {\n          e.preventDefault();\n          if (this.selection) {\n            let row = this.selection.topRow,\n              col = this.selection.leftCol;\n            if (this.copyDownColumns == null || this.copyDownColumns.includes(this.columns[col].binding)) {\n              this.doCopyDownOrRight(row, col, e.code);\n            }\n          }\n        }\n      });\n    }\n    ngOnDestroy() {\n      if (this.errorTooltip != null) {\n        this.errorTooltip.dispose();\n      }\n      if (this.columnHeaderTooltip != null) {\n        this.columnHeaderTooltip.dispose();\n      }\n    }\n    selectionChangedHandler(self, e) {\n      if (e.range.isSingleCell && e.panel.grid._activeCell)\n        // check that one single cell is actually selected\n        {\n          if (e.panel.grid._activeCell.classList.contains(\"wj-state-invalid\")) {\n            self.showMarquee = false; // don't show selection marquee, let error border take priority\n          } else {\n            self.showMarquee = true; // cell is valid, show marquee\n          }\n        } else {\n        self.showMarquee = true; // multiple cells selected, show marquee around all\n      }\n    }\n    loadedRowsHandler(self, eventArgs) {\n      let updatedLayoutHandler = function (s, e) {\n        // Remove the handler as we do not need it anymore\n        s.updatedLayout.removeHandler(updatedLayoutHandler);\n        // Auto size the row headers based on the number of rows\n        s.autoSizeColumn(0, true);\n      };\n      // Add an updated layout handler so we can autosize the row headers\n      // based on the number of rows\n      self.updatedLayout.addHandler(updatedLayoutHandler);\n      //If we don't have any rows, get out\n      if (self.rows == null || self.rows.length === 0) {\n        return;\n      }\n      if (self.disableDefaultSelect) {\n        self.select(-1, -1);\n      } else {\n        //If the specified row to select doesn't exist, select the last row\n        //because it probably means we just deleted the (previous) last row\n        if (self.rows[self.rowToSelect] == null) {\n          self.rowToSelect = self.rows.length - 1;\n        }\n        //The main reason to have onLoadedRows is to select a specified row\n        self.selectRow();\n      }\n      //Some components use the fromOnGridInit flag and it needs to be reset\n      self.fromOnGridInit = false;\n      //Some components turn off selection mode, and it needs to be restored\n      if (self.restoreSelectionMode != null) {\n        self.selectionMode = self.restoreSelectionMode;\n        self.restoreSelectionMode = null;\n      }\n    }\n    selectRow() {\n      this.scrollIntoView(this.rowToSelect, this.colToSelect);\n      this.select(this.rowToSelect, this.colToSelect);\n    }\n    //override default copy action\n    beforeCopyHandler(flex, e) {\n      //support for single cell copying\n      if (flex.selection.isSingleCell) {\n        let clip = flex.getCellData(e.row, e.col, true);\n        Clipboard.copy(clip);\n        e.cancel = true;\n      }\n    }\n    //override default paste action\n    beforePasteHandler(flex, e) {\n      //enabling allows rolling additions from paste\n      flex.allowAddNew = true;\n      flex.pastingInProgress = true;\n      //support for single cell pasting\n      if (e.range.isSingleCell && e.data) {\n        e.cancel = false;\n        flex.setCellData(flex.selection.row, flex.selection.col, e.data);\n        // flex.allowAddNew = false;\n      }\n    }\n    afterPasteHandler(flex, e) {\n      //disable after we are done pasting\n      // flex.allowAddNew = false;\n      flex.pastingInProgress = false;\n      //perform range based rowEditEnd\n      flex.onRowEditEnded(e);\n    }\n    onBeginEditBase(flex, e) {\n      if (this.disableTableCellDict != null && this.cells === e.panel) {\n        let func = this.disableTableCellDict[this.columns[e.col].binding];\n        if (func != null) {\n          e.cancel = func(this, e.row, e.col);\n        }\n      }\n    }\n    onCellEditEndedBase(flex, args) {\n      const {\n        row,\n        col\n      } = args;\n      if (this.fields != null && this.fields[col].dataType === TableFieldDataType.INTEGER) {\n        let value = flex.getCellData(row, col, false);\n        if (value != null) {\n          flex.setCellData(row, col, Math.round(value));\n        }\n      }\n      return true;\n    }\n    onRowEditStartedWrapper(e, runCallback = null) {\n      this.tableHelperFunctions.disableRows({\n        ignoredIndexes: [e.row]\n      });\n      if (runCallback) {\n        runCallback();\n      }\n    }\n    onRowEditStartedWrapperAsync(e, runCallbackAsync = null) {\n      var _this = this;\n      return _asyncToGenerator(function* () {\n        _this.tableHelperFunctions.disableRows({\n          ignoredIndexes: [e.row]\n        });\n        if (runCallbackAsync) {\n          yield runCallbackAsync();\n        }\n      })();\n    }\n    onRowEditEndedWrapper(e, runCallback = null) {\n      this.tableHelperFunctions.disableRow(e.row);\n      try {\n        if (runCallback) {\n          runCallback();\n        }\n      } finally {\n        this.tableHelperFunctions.restoreStates();\n      }\n    }\n    onRowEditEndedWrapperAsync(e, runCallbackAsync = null) {\n      var _this2 = this;\n      return _asyncToGenerator(function* () {\n        _this2.tableHelperFunctions.disableRow(e.row);\n        try {\n          if (runCallbackAsync) {\n            yield runCallbackAsync();\n          }\n        } finally {\n          _this2.tableHelperFunctions.restoreStates();\n        }\n      })();\n    }\n    updateErrorData(rowErrorData, rowId) {\n      var _this3 = this;\n      return _asyncToGenerator(function* () {\n        let previouslyRelatedRows = [];\n        if (rowErrorData == null) {\n          let errorData = _this3.errorData[rowId];\n          if (errorData != null) {\n            // Only need to reset if there was an error\n            errorData.valid = true;\n            errorData.error = null;\n          }\n        } else {\n          let previousRowErrorData = _this3.errorData[rowId] && _this3.errorData[rowId].error;\n          if (previousRowErrorData != null && previousRowErrorData.relatedId !== rowErrorData.relatedId) {\n            previouslyRelatedRows = Object.keys(_this3.errorData).filter(key => _this3.errorData[key].error != null).filter(key => _this3.errorData[key].error.relatedId === rowId);\n          }\n          _this3.errorData[rowId] = {\n            valid: false,\n            error: rowErrorData\n          };\n        }\n      })();\n    }\n    validateFields(rowIndex, validationRules) {\n      var _this4 = this;\n      return _asyncToGenerator(function* () {\n        const dataItem = _this4.rows[rowIndex].dataItem;\n        const errorInfo = _this4.tableHelperFunctions.validateRow(rowIndex, validationRules);\n        yield _this4.updateErrorData(errorInfo.errorFields.length > 0 ? errorInfo : null, dataItem.id);\n        _this4.invalidate();\n      })();\n    }\n    doCopyDownOrRight(row, col, keyCode) {\n      let value = this.getCellData(row, col, false);\n      if (this.enableCopyDown && keyCode === \"KeyD\") {\n        for (let r = row + 1; r < this.rows.length; ++r) {\n          this.setCellData(r, col, value);\n        }\n        if (row + 1 < this.rows.length) {\n          this.copyDownEnded.emit(new CellRangeEventArgs(this.cells, new CellRange(row + 1, col, this.rows.length - 1, col)));\n        }\n      } else if (this.enableCopyRight && keyCode === \"KeyR\") {\n        for (let c = col + 1; c < this.columns.length; ++c) {\n          if (this.isColumnCompatible(col, c)) {\n            this.setCellData(row, c, value);\n          }\n        }\n        if (col + 1 < this.columns.length) {\n          this.copyRightEnded.emit(new CellRangeEventArgs(this.cells, new CellRange(row, col + 1, row, this.columns.length - 1)));\n        }\n      }\n    }\n    isColumnCompatible(startCol, col) {\n      if (this.fields != null) {\n        return this.fields[startCol].dataType === this.fields[col].dataType;\n      }\n      // using wijmo datatypes is a bit risky as an enum column is treated as a string datatype\n      // it is possible an enum column will be changed if source string matches an enum string\n      // use fields to be safe!!!\n      return this.columns[startCol].dataType === this.columns[col].dataType;\n    }\n    static ɵfac = /*@__PURE__*/function () {\n      let ɵWatFlexGridComponent_BaseFactory;\n      return function WatFlexGridComponent_Factory(t) {\n        return (ɵWatFlexGridComponent_BaseFactory || (ɵWatFlexGridComponent_BaseFactory = i0.ɵɵgetInheritedFactory(WatFlexGridComponent)))(t || WatFlexGridComponent);\n      };\n    }();\n    static ɵcmp = /*@__PURE__*/i0.ɵɵdefineComponent({\n      type: WatFlexGridComponent,\n      selectors: [[\"wat-flexgrid\"]],\n      hostVars: 2,\n      hostBindings: function WatFlexGridComponent_HostBindings(rf, ctx) {\n        if (rf & 2) {\n          i0.ɵɵclassProp(\"row-selected\", ctx.rowSelected);\n        }\n      },\n      inputs: {\n        disableTableCellDict: \"disableTableCellDict\",\n        enableCopyDown: \"enableCopyDown\",\n        copyDownColumns: \"copyDownColumns\",\n        enableCopyRight: \"enableCopyRight\"\n      },\n      outputs: {\n        copyDownEnded: \"copyDownEnded\",\n        copyRightEnded: \"copyRightEnded\"\n      },\n      features: [i0.ɵɵProvidersFeature([{\n        provide: 'WjComponent',\n        useExisting: forwardRef(() => WatFlexGridComponent)\n      }, ...wjFlexGridMeta.providers]), i0.ɵɵInheritDefinitionFeature],\n      decls: 0,\n      vars: 0,\n      template: function WatFlexGridComponent_Template(rf, ctx) {},\n      encapsulation: 2\n    });\n  }\n  return WatFlexGridComponent;\n})();","map":null,"metadata":{},"sourceType":"module","externalDependencies":[]}