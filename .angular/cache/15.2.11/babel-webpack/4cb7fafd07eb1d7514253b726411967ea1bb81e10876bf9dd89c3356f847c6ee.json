{"ast":null,"code":"export class TablesStateStoreService {\n  storedTablesStates = {};\n  constructor() {}\n  put(tableId, table) {\n    const tableState = this.getTableState(table);\n    this.storedTablesStates[tableId] = this.storedTablesStates[tableId] ? [...this.storedTablesStates[tableId], tableState] : [tableState];\n  }\n  pop(tableId) {\n    if (!this.storedTablesStates[tableId]) {\n      throw new Error(`Table \\'${tableId}\\' doesn't exist in the store`);\n    }\n    return this.storedTablesStates[tableId].pop();\n  }\n  popAll(tableId) {\n    if (!this.storedTablesStates[tableId]) {\n      throw new Error(`Table \\'${tableId}\\' doesn't exist in the store`);\n    }\n    const tableStates = this.storedTablesStates[tableId];\n    this.storedTablesStates[tableId] = [];\n    // We have to restore each state incrementaly form the latest to the oldest because of LIFO\n    return tableStates.reverse();\n  }\n  getTableState(table) {\n    const tableStateRows = this.getTableStateRows(table.rows);\n    const tableState = {\n      rows: tableStateRows\n    };\n    return tableState;\n  }\n  getTableStateRows(rows) {\n    // Note: if you want to enhance the solution by adding another row fields please follow the next rules:\n    // - If it's a value type - copy as it is\n    // - If it's a reference type - create a deep copy by cloneDeep()\n    const tableStateRows = rows.map(row => ({\n      isReadOnly: row.isReadOnly\n    }));\n    return tableStateRows;\n  }\n}","map":null,"metadata":{},"sourceType":"module","externalDependencies":[]}