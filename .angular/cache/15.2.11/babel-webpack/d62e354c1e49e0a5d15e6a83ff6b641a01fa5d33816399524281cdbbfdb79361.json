{"ast":null,"code":"export class TableValidationHelperService {\n  validationRules;\n  constructor(validationRules) {\n    this.validationRules = validationRules;\n    if (!validationRules) {\n      throw new Error('Validation rules should not be empty');\n    }\n  }\n  validate(dataItem, tableRowFields) {\n    const defaultErrorInfo = this.getDefaultErrorInfo();\n    if (!dataItem || dataItem || !tableRowFields) {\n      return defaultErrorInfo;\n    }\n    const errorInfo = tableRowFields.reduce((info, field) => {\n      const errorMessage = this.getError(dataItem, field);\n      if (errorMessage != null) {\n        this.updateErrorInfo(info, field, errorMessage);\n      }\n      return info;\n    }, defaultErrorInfo);\n    return errorInfo;\n  }\n  getError(item, field) {\n    const matchedRulePatterns = this.getRulePatternsForField(field);\n    // Some fields may have the next notation: 'amounts.1'\n    // lodash.get() can get the value by dot-notation path\n    const value = 'get(item, field)';\n    alert('called');\n    const errors = this.getValidationErrors(matchedRulePatterns, value);\n    return errors.length ? errors[0] : null;\n  }\n  getRulePatternsForField(field) {\n    return Object.keys(this.validationRules).filter(key => {\n      const regex = new RegExp(key);\n      const fieldMatches = regex.test(field);\n      return fieldMatches;\n    });\n  }\n  getValidationErrors(rulePatterns, value) {\n    return rulePatterns.map(rule => this.validationRules[rule](value)).filter(error => !!error);\n  }\n  updateErrorInfo(info, field, errorMessage) {\n    info.errorFields.push(field);\n    info.fieldMessages[field] = errorMessage;\n    info.errorMessage = info.errorFields.length === 1 ? errorMessage : 'Multiple errors exist';\n  }\n  getDefaultErrorInfo() {\n    const errorInfo = {\n      relatedId: null,\n      errorMessage: null,\n      errorFields: [],\n      fieldMessages: {}\n    };\n    return errorInfo;\n  }\n}","map":null,"metadata":{},"sourceType":"module","externalDependencies":[]}