{"ast":null,"code":"import _asyncToGenerator from \"D:/source/wcc-cds/flexgriddemo/node_modules/@babel/runtime/helpers/esm/asyncToGenerator.js\";\nimport { EventEmitter, forwardRef } from '@angular/core';\nimport { Clipboard, Tooltip } from '@grapecity/wijmo';\nimport { WjFlexGrid, wjFlexGridMeta } from '@grapecity/wijmo.angular2.grid';\nimport { AllowSorting, CellRange, CellRangeEventArgs, CellType, SelectionMode } from '@grapecity/wijmo.grid';\nimport { v4 as uuidv4 } from 'uuid';\nimport { FlexgridTooltipHelper } from '../wat-flexgrid/flexgrid-tooltip-helper';\nimport { TableFieldDataType } from 'app/model/types/table-field-data-type.enum';\nimport { TableHelperService } from './table-helper.service';\nimport * as i0 from \"@angular/core\";\nexport let WatFlexGridComponent = /*#__PURE__*/(() => {\n  class WatFlexGridComponent extends WjFlexGrid {\n    colToSelect = 0;\n    rowToSelect = 0;\n    fromOnGridInit = false;\n    restoreSelectionMode = null;\n    observer;\n    tableId;\n    fields;\n    disableDefaultSelect = false;\n    pastingInProgress = false;\n    disableTableCellDict;\n    enableCopyDown = false;\n    copyDownColumns;\n    enableCopyRight = false;\n    copyDownEnded = new EventEmitter();\n    copyRightEnded = new EventEmitter();\n    get rowSelected() {\n      if (this.selectionMode === SelectionMode.Row) {\n        return true;\n      }\n      if (this.selectionMode === SelectionMode.Cell || this.containsFocus() || this.selectedRanges.length !== 1) {\n        return false;\n      }\n      const range = this.selectedRanges[0];\n      return range.row === range.row2 && range.col === 0 && range.col2 === this.columns.length - 1;\n    }\n    errorTooltip;\n    columnHeaderTooltip;\n    tableHelperFunctions;\n    // errorData used for tracking errors on editable table rows\n    errorData =\n    // dictionary\n    {};\n    get hasErrors() {\n      const errorsExist = Object.values(this.errorData).some(record => record.error);\n      return errorsExist;\n    }\n    // [AD] Here is what the derived constructor would need to look like.\n    // Leaving it here as an example, in case it's ever needed.  This was\n    // found in a blog post on how to derive from the Wijmo grid.\n    // constructor(@Inject(ElementRef) elRef: ElementRef,\n    // \t@Inject(Injector) injector: Injector,\n    // \t@Inject('WjComponent') @SkipSelf() @Optional() parentCmp: any,\n    // \t@Inject(ChangeDetectorRef) cdRef: ChangeDetectorRef)\n    // {\n    // \tsuper(elRef, injector, parentCmp, cdRef);\n    // }\n    // [AD] Another blog post on deriving from the grid recommends not using a constructor at all.\n    // This avoids having to maintain parameters and keep them in sync with the base parameters.\n    // Instead, override the \"created\" method, which is called in the last line of any Wijmo\n    // component's constructor, and perform necessary initializations here.\n    created() {\n      this.fields = null;\n      this.showMarquee = true; // for placing a border around groups of selected cells\n      this.anchorCursor = true;\n      this.tableId = uuidv4();\n      this.tableHelperFunctions = new TableHelperService().for(this.tableId, this);\n      // error tooltip\n      this.errorTooltip = new Tooltip();\n      this.errorTooltip.isContentHtml = true;\n      this.errorTooltip.cssClass = \"wj-error-tip\";\n      // column header tooltip\n      this.columnHeaderTooltip = new Tooltip();\n      this.columnHeaderTooltip.isContentHtml = true;\n      this.columnHeaderTooltip.cssClass = \"wj-header-tip top\";\n      this.loadedRows.addHandler(this.loadedRowsHandler);\n      this.selectionChanged.addHandler(this.selectionChangedHandler);\n      //override to pasting behavior\n      this.pasted.addHandler(this.afterPasteHandler);\n      this.pasting.addHandler(this.beforePasteHandler);\n      this.copying.addHandler(this.beforeCopyHandler);\n      // base class handler name needs to be unique - assures this handler and other\n      // cellEditEnded handlers in components that use this component also get called\n      this.beginningEdit.addHandler(this.onBeginEditBase.bind(this));\n      this.cellEditEnded.addHandler(this.onCellEditEndedBase.bind(this));\n      this.formatItem.addHandler(this.formatItemHandlerBase.bind(this));\n      // [AD] This code works for changing the height of the column headers, but it interfered\n      // with the E2E tests. Comment out until we can investigate making E2E more resilient.\n      // this.columnHeaders.rows.defaultSize = 51; // default size for header rows\n      // Don't allow sorting on tables when clicking column header.\n      // There were inconsistencies in the tables, so it works best to turn it off by default\n      // and only turn on in the tables where we want sorting.\n      this.allowSorting = AllowSorting.None;\n      // Set the minimum size of the row headers to 60px so that users can't\n      // resize the column to smaller than 60px.\n      this.rowHeaders.columns.minSize = 60;\n      // Prevent the row headers from being resized and causing other columns to be hidden\n      this.rowHeaders.columns[0].allowResizing = false;\n      this.errorTip.isContentHtml = true;\n      this.refreshOnEdit = true;\n      this.hostElement.addEventListener('keydown', e => {\n        if ((e.code === \"KeyD\" || e.code === \"KeyR\") && e.ctrlKey) {\n          e.preventDefault();\n          if (this.selection) {\n            let row = this.selection.topRow,\n              col = this.selection.leftCol;\n            if (this.copyDownColumns == null || this.copyDownColumns.includes(this.columns[col].binding)) {\n              this.doCopyDownOrRight(row, col, e.code);\n            }\n          }\n        }\n      });\n    }\n    ngOnDestroy() {\n      if (this.errorTooltip != null) {\n        this.errorTooltip.dispose();\n      }\n      if (this.columnHeaderTooltip != null) {\n        this.columnHeaderTooltip.dispose();\n      }\n    }\n    selectionChangedHandler(self, e) {\n      if (e.range.isSingleCell && e.panel.grid._activeCell)\n        // check that one single cell is actually selected\n        {\n          if (e.panel.grid._activeCell.classList.contains(\"wj-state-invalid\")) {\n            self.showMarquee = false; // don't show selection marquee, let error border take priority\n          } else {\n            self.showMarquee = true; // cell is valid, show marquee\n          }\n        } else {\n        self.showMarquee = true; // multiple cells selected, show marquee around all\n      }\n    }\n    formatItemHandlerBase(self, e) {\n      if (this.disableTableCellDict != null && this.cells === e.panel) {\n        let func = this.disableTableCellDict[this.columns[e.col].binding];\n        if (func != null) {\n          let isDisabled = func(this, e.row, e.col);\n          if (isDisabled) {\n            e.cell.classList.add('wj-state-disabled');\n          } else {\n            e.cell.classList.remove('wj-state-disabled');\n          }\n        }\n      }\n      // Remove padding when editing cells\n      if (e.cell.children[0] instanceof HTMLInputElement) {\n        e.cell.style.padding = '0px';\n      }\n      // Put row numbers in for the row headers if we are showing row numbers (Note: in order for\n      // templates to work in specific grids we moved this from the html to here).\n      if (self.rowHeaders === e.panel && e.col === 0) {\n        e.cell.innerHTML = (e.row + 1).toString();\n      }\n      // add tooltip for grid header\n      if (e.panel.cellType === CellType.ColumnHeader && e.getColumn().header?.trim()) {\n        self.columnHeaderTooltip.setTooltip(e.cell, `<span>${e.getColumn().header}</span>`);\n      }\n      if (e.panel.cellType === CellType.Cell) {\n        // set a unique id for each cell\n        // e.cell.setAttribute(\"id\",\n        //     self.tableId.split('-').pop() + '_' + // last portion of the table UUID\n        //     self._e.id + '_' + // table id ex. peakTableComponent\n        //     (e.panel.columns[e.col].header ?? '').replace(/\\s+/g, '') + '_' + // column name without spaces\n        //     e.row\n        // );\n      }\n      // Handle custom error formatting and tooltips\n      if (self.rows == null || self.rows.length === 0) {\n        return;\n      }\n      let dataItem = self.rows[e.row].dataItem;\n      if (dataItem == null || dataItem.id == null) {\n        return;\n      }\n      let errorData = self.errorData[dataItem.id];\n      if (errorData == null) {\n        return;\n      }\n      // Reset the errorTooltip for the cell if one exists\n      // if (self.errorTooltip.getTooltip(e.cell) != null)\n      // {\n      //     self.errorTooltip.setTooltip(e.cell, null);\n      // }\n      // Reset the formatting for an error if one exists\n      if (e.cell.classList.contains('wj-state-invalid')) {\n        e.cell.classList.remove('wj-state-invalid');\n      }\n      if (errorData.valid) {\n        // Row valid no need to add error tooltip or formatting\n        self.errorTooltip.hide();\n        return;\n      }\n      let isErrorCell = false;\n      if (e.panel.cellType === CellType.Cell && errorData.error != null && errorData.error.errorFields != null) {\n        isErrorCell = errorData.error.errorFields.find(f => f === self.columns[e.col].name) != null;\n      }\n      if (e.panel.cellType !== CellType.RowHeader && !isErrorCell) {\n        return;\n      }\n      if (errorData.error != null) {\n        // Error exits, add the class that styles the error for the cell\n        e.cell.classList.add('wj-state-invalid');\n        if (errorData.error.errorMessage != null) {\n          let errorMessage = errorData.error.errorMessage;\n          if (isErrorCell && errorData.error.fieldMessages[self.columns[e.col].name] != null) {\n            errorMessage = errorData.error.fieldMessages[self.columns[e.col].name];\n          }\n          // Message exists, add a errorTooltip for the cell\n          self.errorTooltip.setTooltip(e.cell, FlexgridTooltipHelper.getErrorTooltipHtml(errorMessage));\n        }\n      }\n    }\n    loadedRowsHandler(self, eventArgs) {\n      let updatedLayoutHandler = function (s, e) {\n        // Remove the handler as we do not need it anymore\n        s.updatedLayout.removeHandler(updatedLayoutHandler);\n        // Auto size the row headers based on the number of rows\n        s.autoSizeColumn(0, true);\n      };\n      // Add an updated layout handler so we can autosize the row headers\n      // based on the number of rows\n      self.updatedLayout.addHandler(updatedLayoutHandler);\n      //If we don't have any rows, get out\n      if (self.rows == null || self.rows.length === 0) {\n        return;\n      }\n      if (self.disableDefaultSelect) {\n        self.select(-1, -1);\n      } else {\n        //If the specified row to select doesn't exist, select the last row\n        //because it probably means we just deleted the (previous) last row\n        if (self.rows[self.rowToSelect] == null) {\n          self.rowToSelect = self.rows.length - 1;\n        }\n        //The main reason to have onLoadedRows is to select a specified row\n        self.selectRow();\n      }\n      //Some components use the fromOnGridInit flag and it needs to be reset\n      self.fromOnGridInit = false;\n      //Some components turn off selection mode, and it needs to be restored\n      if (self.restoreSelectionMode != null) {\n        self.selectionMode = self.restoreSelectionMode;\n        self.restoreSelectionMode = null;\n      }\n    }\n    selectRow() {\n      this.scrollIntoView(this.rowToSelect, this.colToSelect);\n      this.select(this.rowToSelect, this.colToSelect);\n    }\n    //override default copy action\n    beforeCopyHandler(flex, e) {\n      //support for single cell copying\n      if (flex.selection.isSingleCell) {\n        let clip = flex.getCellData(e.row, e.col, true);\n        Clipboard.copy(clip);\n        e.cancel = true;\n      }\n    }\n    //override default paste action\n    beforePasteHandler(flex, e) {\n      //enabling allows rolling additions from paste\n      flex.allowAddNew = true;\n      flex.pastingInProgress = true;\n      //support for single cell pasting\n      if (e.range.isSingleCell && e.data) {\n        e.cancel = false;\n        flex.setCellData(flex.selection.row, flex.selection.col, e.data);\n        flex.allowAddNew = false;\n      }\n    }\n    afterPasteHandler(flex, e) {\n      //disable after we are done pasting\n      flex.allowAddNew = false;\n      flex.pastingInProgress = false;\n      //perform range based rowEditEnd\n      flex.onRowEditEnded(e);\n    }\n    onBeginEditBase(flex, e) {\n      if (this.disableTableCellDict != null && this.cells === e.panel) {\n        let func = this.disableTableCellDict[this.columns[e.col].binding];\n        if (func != null) {\n          e.cancel = func(this, e.row, e.col);\n        }\n      }\n    }\n    onCellEditEndedBase(flex, args) {\n      const {\n        row,\n        col\n      } = args;\n      if (this.fields != null && this.fields[col].dataType === TableFieldDataType.INTEGER) {\n        let value = flex.getCellData(row, col, false);\n        if (value != null) {\n          flex.setCellData(row, col, Math.round(value));\n        }\n      }\n      return true;\n    }\n    onRowEditStartedWrapper(e, runCallback = null) {\n      this.tableHelperFunctions.disableRows({\n        ignoredIndexes: [e.row]\n      });\n      if (runCallback) {\n        runCallback();\n      }\n    }\n    onRowEditStartedWrapperAsync(e, runCallbackAsync = null) {\n      var _this = this;\n      return _asyncToGenerator(function* () {\n        _this.tableHelperFunctions.disableRows({\n          ignoredIndexes: [e.row]\n        });\n        if (runCallbackAsync) {\n          yield runCallbackAsync();\n        }\n      })();\n    }\n    onRowEditEndedWrapper(e, runCallback = null) {\n      this.tableHelperFunctions.disableRow(e.row);\n      try {\n        if (runCallback) {\n          runCallback();\n        }\n      } finally {\n        this.tableHelperFunctions.restoreStates();\n      }\n    }\n    onRowEditEndedWrapperAsync(e, runCallbackAsync = null) {\n      var _this2 = this;\n      return _asyncToGenerator(function* () {\n        _this2.tableHelperFunctions.disableRow(e.row);\n        try {\n          if (runCallbackAsync) {\n            yield runCallbackAsync();\n          }\n        } finally {\n          _this2.tableHelperFunctions.restoreStates();\n        }\n      })();\n    }\n    updateErrorData(rowErrorData, rowId) {\n      var _this3 = this;\n      return _asyncToGenerator(function* () {\n        let previouslyRelatedRows = [];\n        if (rowErrorData == null) {\n          let errorData = _this3.errorData[rowId];\n          if (errorData != null) {\n            // Only need to reset if there was an error\n            errorData.valid = true;\n            errorData.error = null;\n          }\n        } else {\n          let previousRowErrorData = _this3.errorData[rowId] && _this3.errorData[rowId].error;\n          if (previousRowErrorData != null && previousRowErrorData.relatedId !== rowErrorData.relatedId) {\n            previouslyRelatedRows = Object.keys(_this3.errorData).filter(key => _this3.errorData[key].error != null).filter(key => _this3.errorData[key].error.relatedId === rowId);\n          }\n          _this3.errorData[rowId] = {\n            valid: false,\n            error: rowErrorData\n          };\n        }\n      })();\n    }\n    validateFields(rowIndex, validationRules) {\n      var _this4 = this;\n      return _asyncToGenerator(function* () {\n        const dataItem = _this4.rows[rowIndex].dataItem;\n        const errorInfo = _this4.tableHelperFunctions.validateRow(rowIndex, validationRules);\n        yield _this4.updateErrorData(errorInfo.errorFields.length > 0 ? errorInfo : null, dataItem.id);\n        _this4.invalidate();\n      })();\n    }\n    doCopyDownOrRight(row, col, keyCode) {\n      let value = this.getCellData(row, col, false);\n      if (this.enableCopyDown && keyCode === \"KeyD\") {\n        for (let r = row + 1; r < this.rows.length; ++r) {\n          this.setCellData(r, col, value);\n        }\n        if (row + 1 < this.rows.length) {\n          this.copyDownEnded.emit(new CellRangeEventArgs(this.cells, new CellRange(row + 1, col, this.rows.length - 1, col)));\n        }\n      } else if (this.enableCopyRight && keyCode === \"KeyR\") {\n        for (let c = col + 1; c < this.columns.length; ++c) {\n          if (this.isColumnCompatible(col, c)) {\n            this.setCellData(row, c, value);\n          }\n        }\n        if (col + 1 < this.columns.length) {\n          this.copyRightEnded.emit(new CellRangeEventArgs(this.cells, new CellRange(row, col + 1, row, this.columns.length - 1)));\n        }\n      }\n    }\n    isColumnCompatible(startCol, col) {\n      if (this.fields != null) {\n        return this.fields[startCol].dataType === this.fields[col].dataType;\n      }\n      // using wijmo datatypes is a bit risky as an enum column is treated as a string datatype\n      // it is possible an enum column will be changed if source string matches an enum string\n      // use fields to be safe!!!\n      return this.columns[startCol].dataType === this.columns[col].dataType;\n    }\n    static ɵfac = /*@__PURE__*/function () {\n      let ɵWatFlexGridComponent_BaseFactory;\n      return function WatFlexGridComponent_Factory(t) {\n        return (ɵWatFlexGridComponent_BaseFactory || (ɵWatFlexGridComponent_BaseFactory = i0.ɵɵgetInheritedFactory(WatFlexGridComponent)))(t || WatFlexGridComponent);\n      };\n    }();\n    static ɵcmp = /*@__PURE__*/i0.ɵɵdefineComponent({\n      type: WatFlexGridComponent,\n      selectors: [[\"wat-flexgrid\"]],\n      hostVars: 2,\n      hostBindings: function WatFlexGridComponent_HostBindings(rf, ctx) {\n        if (rf & 2) {\n          i0.ɵɵclassProp(\"row-selected\", ctx.rowSelected);\n        }\n      },\n      inputs: {\n        disableTableCellDict: \"disableTableCellDict\",\n        enableCopyDown: \"enableCopyDown\",\n        copyDownColumns: \"copyDownColumns\",\n        enableCopyRight: \"enableCopyRight\"\n      },\n      outputs: {\n        copyDownEnded: \"copyDownEnded\",\n        copyRightEnded: \"copyRightEnded\"\n      },\n      features: [i0.ɵɵProvidersFeature([{\n        provide: 'WjComponent',\n        useExisting: forwardRef(() => WatFlexGridComponent)\n      }, ...wjFlexGridMeta.providers]), i0.ɵɵInheritDefinitionFeature],\n      decls: 0,\n      vars: 0,\n      template: function WatFlexGridComponent_Template(rf, ctx) {},\n      encapsulation: 2\n    });\n  }\n  return WatFlexGridComponent;\n})();","map":null,"metadata":{},"sourceType":"module","externalDependencies":[]}