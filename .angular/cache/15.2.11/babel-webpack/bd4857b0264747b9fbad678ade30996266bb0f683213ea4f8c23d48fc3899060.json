{"ast":null,"code":"import _asyncToGenerator from \"D:/source/wcc-cds/flexgriddemo/node_modules/@babel/runtime/helpers/esm/asyncToGenerator.js\";\nimport { WatFlexGridComponent } from './components/wat-flexgrid/wat-flexgrid.component';\nimport { CollectionView } from '@grapecity/wijmo';\nimport { Column, DataMap, DataMapEditor } from '@grapecity/wijmo.grid';\nimport { MethodService } from './services/method.service';\nimport { ComponentType } from './model/method-component-type.enum';\nimport * as i0 from \"@angular/core\";\nimport * as i1 from \"./services/method.service\";\nimport * as i2 from \"./components/wat-flexgrid/wat-flexgrid.component\";\nconst _c0 = [\"compsflex\"];\nconst _c1 = [\"globalFields\"];\nexport let AppComponent = /*#__PURE__*/(() => {\n  class AppComponent {\n    methodService;\n    title = 'FlexGrid Demo Application';\n    selectedRow = '1';\n    componentId = 'Comp1';\n    offsetHeight;\n    splitterMoveCount = 0;\n    info;\n    data;\n    flex;\n    globalFieldsTable;\n    disableTableCellDict = {\n      \"expectedRetTime\": () => {\n        return true;\n      },\n      \"isInternalStd\": (flex, row) => this.canNotBeUsedAsInternalStd(flex, row),\n      \"useInternalStd\": (flex, row) => this.isNamedGroup(flex, row),\n      \"expectedWavelength\": (flex, row) => this.isNamedGroup(flex, row),\n      \"expectedMass\": (flex, row) => this.isNamedGroup(flex, row),\n      \"channelName\": (flex, row) => this.isNamedGroup(flex, row)\n    };\n    isReadOnly;\n    errorMessage;\n    /**\r\n     *\r\n     */\n    constructor(methodService) {\n      this.methodService = methodService;\n    }\n    selecteRowChanged(row) {\n      this.selectedRow = row;\n    }\n    ngOnInit() {\n      var _this = this;\n      return _asyncToGenerator(function* () {\n        _this.isReadOnly = false;\n        _this.flex.isReadOnly = _this.isReadOnly;\n        yield _this.onGridInit();\n      })();\n    }\n    onGridInit() {\n      var _this2 = this;\n      return _asyncToGenerator(function* () {\n        try {\n          _this2.info = yield _this2.methodService.getComponentsAsync(1);\n          console.log(_this2.info);\n          if (_this2.info == null) {\n            _this2.errorMessage = \"Problem retrieving components of the method\";\n          } else {\n            _this2.data = new CollectionView(_this2.info.data);\n            _this2.data.trackChanges = true;\n            _this2.createColumns(_this2.info);\n          }\n        } catch (error) {\n          _this2.errorMessage = error;\n        }\n        // Use onRowEditStarted to reset editing properties\n        _this2.flex.onRowEditStarted = e => {\n          //Skip saving if pasting\n          if (_this2.flex.pastingInProgress) {\n            e.cancel = true;\n            return;\n          }\n          _this2.flex.onRowEditStartedWrapper(e, () => _this2.onRowEditStarted(e));\n        };\n        // Use onRowEditEnded to perform row validation\n        _this2.flex.onRowEditEnded = /*#__PURE__*/function () {\n          var _ref = _asyncToGenerator(function* (e) {\n            //Skip saving if pasting\n            if (_this2.flex.pastingInProgress) {\n              e.cancel = true;\n              return;\n            }\n            yield _this2.flex.onRowEditEndedWrapperAsync(e, /*#__PURE__*/_asyncToGenerator(function* () {\n              return yield _this2.onRowEditEnded(e);\n            }));\n          });\n          return function (_x) {\n            return _ref.apply(this, arguments);\n          };\n        }();\n        _this2.flex.validateEdits = false; //don't force user to stay in error cell\n        yield _this2.initGlobalFieldsTable();\n      })();\n    }\n    initGlobalFieldsTable() {\n      var _this3 = this;\n      return _asyncToGenerator(function* () {\n        if (_this3.info?.globalFields?.length > 0) {\n          let dataArray = new Array();\n          dataArray[0] = _this3.info.customFields;\n          // this.globalData = new CollectionView(dataArray);\n          _this3.globalFieldsTable.autoGenerateColumns = false;\n          _this3.globalFieldsTable.columns.clear();\n          _this3.globalFieldsTable.fields = _this3.info.globalFields;\n          for (let i = 0; i < _this3.info.globalFields.length; i++) {\n            let bindingKey = _this3.info.globalFields[i].bindingKey;\n            bindingKey = bindingKey.substring(bindingKey.indexOf(\".\") + 1);\n            _this3.globalFieldsTable.columns.push(new Column({\n              name: bindingKey,\n              binding: bindingKey,\n              header: _this3.info.globalFields[i].displayName,\n              width: 200,\n              minWidth: 100,\n              isRequired: false,\n              dataType: _this3.info.globalFields[i].dataType\n            }));\n          }\n          _this3.globalFieldsTable.onRowEditEnded = /*#__PURE__*/function () {\n            var _ref3 = _asyncToGenerator(function* (e) {\n              yield _this3.globalFieldsTable.onRowEditEndedWrapperAsync(e, /*#__PURE__*/_asyncToGenerator(function* () {\n                return yield _this3.onGlobalTableRowEditEnded(e);\n              }));\n            });\n            return function (_x2) {\n              return _ref3.apply(this, arguments);\n            };\n          }();\n        }\n      })();\n    }\n    onGridBeginningEdit(flex, args) {\n      return _asyncToGenerator(function* () {\n        let col = flex.columns[args.col];\n        let row = flex.rows[args.row];\n        let compNames = [];\n        if (col.binding === 'useInternalStd') {\n          // If this component is already selected as an internal standard, it can't also use an internal standard.\n          // So only collect a list of possible names if the component is not marked as an internal standard.\n          if (row.dataItem.isInternalStd === false) {\n            for (let i = 0; i < flex.rows.length; i++) {\n              if (flex.rows[i].dataItem.name && flex.rows[i].dataItem.isInternalStd === true && flex.rows[i] !== row) {\n                compNames.push(flex.rows[i].dataItem.name);\n              }\n            }\n          }\n          col.dataMap = new DataMap(compNames);\n        }\n      })();\n    }\n    isPageValid() {\n      let methodValid = true;\n      // Find the first occurence of an error in the table,\n      // if index === -1 the table is valid\n      let index = this.flex.rows.findIndex(e => e.dataItem.error != null);\n      if (index !== -1) {\n        methodValid = false;\n      }\n      // Set method validity\n      //  this.methodValidService.setIsPageSettingsValid(methodValid);\n      return methodValid;\n    }\n    onRowEditStarted(e) {\n      this.flex.rows[e.row].dataItem.error = null;\n    }\n    onCopyDownEnded(_e) {\n      var _this4 = this;\n      return _asyncToGenerator(function* () {\n        yield _this4.validateComponents();\n      })();\n    }\n    validateComponents() {\n      return _asyncToGenerator(function* () {})();\n    } // let customFields = this.globalData != null ? this.globalData.items[0] : null;\n    // let comps = await this.methodService.validateComponentsAsync({\n    //     \"data\": this.data.items, \"columns\": null,\n    //     \"globalFields\": null, \"customFields\": customFields\n    // });\n    // // Copy contents of data into existing CollectionView\n    // for (let index = 0; index < this.data.items.length; index++) {\n    //     Object.assign(this.data.items[index], comps.data[index]);\n    // }\n    // await this.updateErrorData(comps);\n    updateErrorData(comps) {\n      var _this5 = this;\n      return _asyncToGenerator(function* () {\n        for (let comp of comps.data) {\n          yield _this5.flex.updateErrorData(comp.error, comp.id);\n        }\n        _this5.flex.invalidate();\n      })();\n    }\n    onGlobalTableRowEditEnded(e) {\n      return _asyncToGenerator(function* () {})();\n    }\n    refreshTables() {\n      // the idea here is to only refresh the top table if the splitter is moved dowm or\n      // the bottom table if ths splitter is moved up. The table itself handles refreshing \n      // properly if the table height is getting smaller\n      // if (this.meCompsTableComponent !== null)\n      // {        \n      //     let currentOffsetHeight = this.meCompsTableComponent.flex.hostElement.offsetHeight;        \n      //     if (currentOffsetHeight > this.offsetHeight)\n      //     {\n      //         this.meCompsTableComponent.onResize();                   \n      //     }\n      //     else if (currentOffsetHeight < this.offsetHeight && this.meCompsCVTableComponent !== null)\n      //     {\n      //         this.meCompsCVTableComponent.onResize();                    \n      //     }\n      // }          \n    }\n    canNotBeUsedAsInternalStd(flex, rowNumber) {\n      let row = flex.rows[rowNumber];\n      return row.dataItem !== null && row.dataItem.type !== ComponentType.Target;\n    }\n    isNamedGroup(flex, rowNumber) {\n      let row = flex.rows[rowNumber];\n      return row.dataItem != null && row.dataItem.type === ComponentType.NamedGroup;\n    }\n    onCellEditEnded(e) {\n      var _this6 = this;\n      return _asyncToGenerator(function* () {\n        let col = _this6.flex.columns[e.col];\n        let row = _this6.flex.rows[e.row];\n        if (row?.dataItem !== null && col?.binding === 'type') {\n          // validate immediately\n          yield _this6.validateComponents();\n          // raise error for identification\n          // if (this.compIdentSettings == null) {\n          //     const compsIdent = await this.methodService.getCompsIdentSettingsAsync(this.methodId);\n          //     this.compIdentSettings = compsIdent.compIdentTable.items;\n          // }\n          // var identSetting = this.compIdentSettings.find(s => s.id === row.dataItem.id);\n          // if (identSetting?.type !== row.dataItem.type) {\n          //     this.changedComponentType = true;\n          //     this.updateIdentificationSettingsErrors();\n          // }\n        }\n      })();\n    }\n    createColumns(info) {\n      this.flex.autoGenerateColumns = false;\n      this.flex.columns.clear();\n      this.flex.fields = info.columns;\n      for (let i = 0; i < info.columns.length; i++) {\n        const bindingKey = info.columns[i].bindingKey;\n        this.flex.columns.push(new Column({\n          name: bindingKey,\n          binding: bindingKey,\n          header: info.columns[i].displayName,\n          width: '*',\n          minWidth: 100,\n          isRequired: this.isColumnRequired(bindingKey),\n          dataType: info.columns[i].dataType,\n          dataMap: this.setDataMap(info.columns[i]),\n          dataMapEditor: bindingKey === 'useInternalStd' ? DataMapEditor.DropDownList : null\n        }));\n      }\n    }\n    onRowEditEnded(e) {\n      var _this7 = this;\n      return _asyncToGenerator(function* () {\n        if (_this7.flex.allowAddNew) {\n          return;\n        }\n        //Mark grid as readonly while validate is happening, so that the user\n        //can't start editing another row while the data is potentially being replaced.\n        _this7.flex.isReadOnly = true;\n        try {\n          yield _this7.validateComponents();\n          _this7.flex.rowToSelect = e.row;\n          _this7.flex.isReadOnly = false;\n        } catch (error) {\n          _this7.errorMessage = \"Problem saving component to method.\";\n          _this7.flex.isReadOnly = false;\n        }\n      })();\n    }\n    isColumnRequired(bindingKey) {\n      return bindingKey === 'isInternalStd';\n    }\n    setDataMap(field) {\n      if (field.bindingKey === 'useInternalStd') {\n        return new DataMap(new Array());\n      }\n      if (field.bindingKey === 'type') {\n        // allow only the types that are available now\n        return new DataMap(field.enumerations.filter(e => e.value === ComponentType.Target || e.value === ComponentType.TimedGroup || e.value === ComponentType.Candidate || e.value === ComponentType.NamedGroup), 'value', 'displayName');\n      }\n      return null;\n    }\n    static ɵfac = function AppComponent_Factory(t) {\n      return new (t || AppComponent)(i0.ɵɵdirectiveInject(i1.MethodService));\n    };\n    static ɵcmp = /*@__PURE__*/i0.ɵɵdefineComponent({\n      type: AppComponent,\n      selectors: [[\"app-root\"]],\n      viewQuery: function AppComponent_Query(rf, ctx) {\n        if (rf & 1) {\n          i0.ɵɵviewQuery(_c0, 7);\n          i0.ɵɵviewQuery(_c1, 5);\n        }\n        if (rf & 2) {\n          let _t;\n          i0.ɵɵqueryRefresh(_t = i0.ɵɵloadQuery()) && (ctx.flex = _t.first);\n          i0.ɵɵqueryRefresh(_t = i0.ɵɵloadQuery()) && (ctx.globalFieldsTable = _t.first);\n        }\n      },\n      decls: 2,\n      vars: 4,\n      consts: [[\"id\", \"tableComponents\", \"selectionMode\", \"MultiRange\", 3, \"itemsSource\", \"enableCopyDown\", \"enableCopyRight\", \"disableTableCellDict\", \"beginningEdit\", \"lostFocus\", \"cellEditEnded\"], [\"compsflex\", \"\"]],\n      template: function AppComponent_Template(rf, ctx) {\n        if (rf & 1) {\n          i0.ɵɵelementStart(0, \"wat-flexgrid\", 0, 1);\n          i0.ɵɵlistener(\"beginningEdit\", function AppComponent_Template_wat_flexgrid_beginningEdit_0_listener($event) {\n            return ctx.onGridBeginningEdit(ctx.flex, $event);\n          })(\"lostFocus\", function AppComponent_Template_wat_flexgrid_lostFocus_0_listener() {\n            return ctx.isPageValid();\n          })(\"cellEditEnded\", function AppComponent_Template_wat_flexgrid_cellEditEnded_0_listener($event) {\n            return ctx.onCellEditEnded($event);\n          });\n          i0.ɵɵelementEnd();\n        }\n        if (rf & 2) {\n          i0.ɵɵproperty(\"itemsSource\", ctx.data)(\"enableCopyDown\", !ctx.isReadOnly)(\"enableCopyRight\", false)(\"disableTableCellDict\", ctx.disableTableCellDict);\n        }\n      },\n      dependencies: [i2.WatFlexGridComponent]\n    });\n  }\n  return AppComponent;\n})();","map":null,"metadata":{},"sourceType":"module","externalDependencies":[]}