{"ast":null,"code":"import * as i0 from '@angular/core';\nimport { InjectionToken, EventEmitter, Component, ChangeDetectionStrategy, ViewEncapsulation, Optional, Inject, Input, Output, ViewChildren, Directive, NgModule } from '@angular/core';\nimport * as i1 from '@angular/common';\nimport { CommonModule } from '@angular/common';\nimport { Subject, Observable } from 'rxjs';\nimport { debounceTime } from 'rxjs/operators';\nconst _c0 = [\"gutterEls\"];\nfunction SplitComponent_ng_template_1_div_0_Template(rf, ctx) {\n  if (rf & 1) {\n    const _r8 = i0.ɵɵgetCurrentView();\n    i0.ɵɵelementStart(0, \"div\", 2, 3);\n    i0.ɵɵlistener(\"keydown\", function SplitComponent_ng_template_1_div_0_Template_div_keydown_0_listener($event) {\n      i0.ɵɵrestoreView(_r8);\n      const index_r2 = i0.ɵɵnextContext().index;\n      const ctx_r6 = i0.ɵɵnextContext();\n      return i0.ɵɵresetView(ctx_r6.startKeyboardDrag($event, index_r2 * 2 + 1, index_r2 + 1));\n    })(\"mousedown\", function SplitComponent_ng_template_1_div_0_Template_div_mousedown_0_listener($event) {\n      i0.ɵɵrestoreView(_r8);\n      const index_r2 = i0.ɵɵnextContext().index;\n      const ctx_r9 = i0.ɵɵnextContext();\n      return i0.ɵɵresetView(ctx_r9.startMouseDrag($event, index_r2 * 2 + 1, index_r2 + 1));\n    })(\"touchstart\", function SplitComponent_ng_template_1_div_0_Template_div_touchstart_0_listener($event) {\n      i0.ɵɵrestoreView(_r8);\n      const index_r2 = i0.ɵɵnextContext().index;\n      const ctx_r11 = i0.ɵɵnextContext();\n      return i0.ɵɵresetView(ctx_r11.startMouseDrag($event, index_r2 * 2 + 1, index_r2 + 1));\n    })(\"mouseup\", function SplitComponent_ng_template_1_div_0_Template_div_mouseup_0_listener($event) {\n      i0.ɵɵrestoreView(_r8);\n      const index_r2 = i0.ɵɵnextContext().index;\n      const ctx_r13 = i0.ɵɵnextContext();\n      return i0.ɵɵresetView(ctx_r13.clickGutter($event, index_r2 + 1));\n    })(\"touchend\", function SplitComponent_ng_template_1_div_0_Template_div_touchend_0_listener($event) {\n      i0.ɵɵrestoreView(_r8);\n      const index_r2 = i0.ɵɵnextContext().index;\n      const ctx_r15 = i0.ɵɵnextContext();\n      return i0.ɵɵresetView(ctx_r15.clickGutter($event, index_r2 + 1));\n    });\n    i0.ɵɵelement(2, \"div\", 4);\n    i0.ɵɵelementEnd();\n  }\n  if (rf & 2) {\n    const ctx_r17 = i0.ɵɵnextContext();\n    const index_r2 = ctx_r17.index;\n    const area_r1 = ctx_r17.$implicit;\n    const ctx_r4 = i0.ɵɵnextContext();\n    i0.ɵɵstyleProp(\"flex-basis\", ctx_r4.gutterSize, \"px\")(\"order\", index_r2 * 2 + 1);\n    i0.ɵɵattribute(\"aria-label\", ctx_r4.gutterAriaLabel)(\"aria-orientation\", ctx_r4.direction)(\"aria-valuemin\", area_r1.minSize)(\"aria-valuemax\", area_r1.maxSize)(\"aria-valuenow\", area_r1.size)(\"aria-valuetext\", ctx_r4.getAriaAreaSizeText(area_r1.size));\n  }\n}\nfunction SplitComponent_ng_template_1_Template(rf, ctx) {\n  if (rf & 1) {\n    i0.ɵɵtemplate(0, SplitComponent_ng_template_1_div_0_Template, 3, 10, \"div\", 1);\n  }\n  if (rf & 2) {\n    const last_r3 = ctx.last;\n    i0.ɵɵproperty(\"ngIf\", last_r3 === false);\n  }\n}\nconst _c1 = [\"*\"];\nfunction getPointFromEvent(event) {\n  // TouchEvent\n  if (event.changedTouches !== undefined && event.changedTouches.length > 0) {\n    return {\n      x: event.changedTouches[0].clientX,\n      y: event.changedTouches[0].clientY\n    };\n  }\n  // MouseEvent\n  else if (event.clientX !== undefined && event.clientY !== undefined) {\n    return {\n      x: event.clientX,\n      y: event.clientY\n    };\n  }\n  // KeyboardEvent\n  else if (event.currentTarget !== undefined) {\n    const gutterEl = event.currentTarget;\n    return {\n      x: gutterEl.offsetLeft,\n      y: gutterEl.offsetTop\n    };\n  }\n  return null;\n}\nfunction pointDeltaEquals(lhs, rhs, deltaPx) {\n  return Math.abs(lhs.x - rhs.x) <= deltaPx && Math.abs(lhs.y - rhs.y) <= deltaPx;\n}\nfunction getKeyboardEndpoint(event, direction) {\n  // Return null if direction keys on the opposite axis were pressed\n  if (direction === 'horizontal') {\n    switch (event.key) {\n      case 'ArrowLeft':\n      case 'ArrowRight':\n      case 'PageUp':\n      case 'PageDown':\n        break;\n      default:\n        return null;\n    }\n  }\n  if (direction === 'vertical') {\n    switch (event.key) {\n      case 'ArrowUp':\n      case 'ArrowDown':\n      case 'PageUp':\n      case 'PageDown':\n        break;\n      default:\n        return null;\n    }\n  }\n  const gutterEl = event.currentTarget;\n  const offset = event.key === 'PageUp' || event.key === 'PageDown' ? 50 * 10 : 50;\n  let offsetX = gutterEl.offsetLeft,\n    offsetY = gutterEl.offsetTop;\n  switch (event.key) {\n    case 'ArrowLeft':\n      offsetX -= offset;\n      break;\n    case 'ArrowRight':\n      offsetX += offset;\n      break;\n    case 'ArrowUp':\n      offsetY -= offset;\n      break;\n    case 'ArrowDown':\n      offsetY += offset;\n      break;\n    case 'PageUp':\n      if (direction === 'vertical') {\n        offsetY -= offset;\n      } else {\n        offsetX += offset;\n      }\n      break;\n    case 'PageDown':\n      if (direction === 'vertical') {\n        offsetY += offset;\n      } else {\n        offsetX -= offset;\n      }\n      break;\n    default:\n      return null;\n  }\n  return {\n    x: offsetX,\n    y: offsetY\n  };\n}\nfunction getElementPixelSize(elRef, direction) {\n  const rect = elRef.nativeElement.getBoundingClientRect();\n  return direction === 'horizontal' ? rect.width : rect.height;\n}\nfunction getInputBoolean(v) {\n  return typeof v === 'boolean' ? v : v === 'false' ? false : true;\n}\nfunction getInputPositiveNumber(v, defaultValue) {\n  if (v === null || v === undefined) return defaultValue;\n  v = Number(v);\n  return !isNaN(v) && v >= 0 ? v : defaultValue;\n}\nfunction isUserSizesValid(unit, sizes) {\n  // All sizes have to be not null and total should be 100\n  if (unit === 'percent') {\n    const total = sizes.reduce((total, s) => s !== null ? total + s : total, 0);\n    return sizes.every(s => s !== null) && total > 99.9 && total < 100.1;\n  }\n  // A size at null is mandatory but only one.\n  if (unit === 'pixel') {\n    return sizes.filter(s => s === null).length === 1;\n  }\n}\nfunction getAreaMinSize(a) {\n  if (a.size === null) {\n    return null;\n  }\n  if (a.component.lockSize === true) {\n    return a.size;\n  }\n  if (a.component.minSize === null) {\n    return null;\n  }\n  if (a.component.minSize > a.size) {\n    return a.size;\n  }\n  return a.component.minSize;\n}\nfunction getAreaMaxSize(a) {\n  if (a.size === null) {\n    return null;\n  }\n  if (a.component.lockSize === true) {\n    return a.size;\n  }\n  if (a.component.maxSize === null) {\n    return null;\n  }\n  if (a.component.maxSize < a.size) {\n    return a.size;\n  }\n  return a.component.maxSize;\n}\nfunction getGutterSideAbsorptionCapacity(unit, sideAreas, pixels, allAreasSizePixel) {\n  return sideAreas.reduce((acc, area) => {\n    const res = getAreaAbsorptionCapacity(unit, area, acc.remain, allAreasSizePixel);\n    acc.list.push(res);\n    acc.remain = res.pixelRemain;\n    return acc;\n  }, {\n    remain: pixels,\n    list: []\n  });\n}\nfunction getAreaAbsorptionCapacity(unit, areaSnapshot, pixels, allAreasSizePixel) {\n  // No pain no gain\n  if (pixels === 0) {\n    return {\n      areaSnapshot,\n      pixelAbsorb: 0,\n      percentAfterAbsorption: areaSnapshot.sizePercentAtStart,\n      pixelRemain: 0\n    };\n  }\n  // Area start at zero and need to be reduced, not possible\n  if (areaSnapshot.sizePixelAtStart === 0 && pixels < 0) {\n    return {\n      areaSnapshot,\n      pixelAbsorb: 0,\n      percentAfterAbsorption: 0,\n      pixelRemain: pixels\n    };\n  }\n  if (unit === 'percent') {\n    return getAreaAbsorptionCapacityPercent(areaSnapshot, pixels, allAreasSizePixel);\n  }\n  if (unit === 'pixel') {\n    return getAreaAbsorptionCapacityPixel(areaSnapshot, pixels, allAreasSizePixel);\n  }\n}\nfunction getAreaAbsorptionCapacityPercent(areaSnapshot, pixels, allAreasSizePixel) {\n  const tempPixelSize = areaSnapshot.sizePixelAtStart + pixels;\n  const tempPercentSize = tempPixelSize / allAreasSizePixel * 100;\n  // ENLARGE AREA\n  if (pixels > 0) {\n    // If maxSize & newSize bigger than it > absorb to max and return remaining pixels\n    if (areaSnapshot.area.maxSize !== null && tempPercentSize > areaSnapshot.area.maxSize) {\n      // Use area.area.maxSize as newPercentSize and return calculate pixels remaining\n      const maxSizePixel = areaSnapshot.area.maxSize / 100 * allAreasSizePixel;\n      return {\n        areaSnapshot,\n        pixelAbsorb: maxSizePixel,\n        percentAfterAbsorption: areaSnapshot.area.maxSize,\n        pixelRemain: areaSnapshot.sizePixelAtStart + pixels - maxSizePixel\n      };\n    }\n    return {\n      areaSnapshot,\n      pixelAbsorb: pixels,\n      percentAfterAbsorption: tempPercentSize > 100 ? 100 : tempPercentSize,\n      pixelRemain: 0\n    };\n  }\n  // REDUCE AREA\n  else if (pixels < 0) {\n    // If minSize & newSize smaller than it > absorb to min and return remaining pixels\n    if (areaSnapshot.area.minSize !== null && tempPercentSize < areaSnapshot.area.minSize) {\n      // Use area.area.minSize as newPercentSize and return calculate pixels remaining\n      const minSizePixel = areaSnapshot.area.minSize / 100 * allAreasSizePixel;\n      return {\n        areaSnapshot,\n        pixelAbsorb: minSizePixel,\n        percentAfterAbsorption: areaSnapshot.area.minSize,\n        pixelRemain: areaSnapshot.sizePixelAtStart + pixels - minSizePixel\n      };\n    }\n    // If reduced under zero > return remaining pixels\n    else if (tempPercentSize < 0) {\n      // Use 0 as newPercentSize and return calculate pixels remaining\n      return {\n        areaSnapshot,\n        pixelAbsorb: -areaSnapshot.sizePixelAtStart,\n        percentAfterAbsorption: 0,\n        pixelRemain: pixels + areaSnapshot.sizePixelAtStart\n      };\n    }\n    return {\n      areaSnapshot,\n      pixelAbsorb: pixels,\n      percentAfterAbsorption: tempPercentSize,\n      pixelRemain: 0\n    };\n  }\n}\nfunction getAreaAbsorptionCapacityPixel(areaSnapshot, pixels, containerSizePixel) {\n  const tempPixelSize = areaSnapshot.sizePixelAtStart + pixels;\n  // ENLARGE AREA\n  if (pixels > 0) {\n    // If maxSize & newSize bigger than it > absorb to max and return remaining pixels\n    if (areaSnapshot.area.maxSize !== null && tempPixelSize > areaSnapshot.area.maxSize) {\n      return {\n        areaSnapshot,\n        pixelAbsorb: areaSnapshot.area.maxSize - areaSnapshot.sizePixelAtStart,\n        percentAfterAbsorption: -1,\n        pixelRemain: tempPixelSize - areaSnapshot.area.maxSize\n      };\n    }\n    return {\n      areaSnapshot,\n      pixelAbsorb: pixels,\n      percentAfterAbsorption: -1,\n      pixelRemain: 0\n    };\n  }\n  // REDUCE AREA\n  else if (pixels < 0) {\n    // If minSize & newSize smaller than it > absorb to min and return remaining pixels\n    if (areaSnapshot.area.minSize !== null && tempPixelSize < areaSnapshot.area.minSize) {\n      return {\n        areaSnapshot,\n        pixelAbsorb: areaSnapshot.area.minSize + pixels - tempPixelSize,\n        percentAfterAbsorption: -1,\n        pixelRemain: tempPixelSize - areaSnapshot.area.minSize\n      };\n    }\n    // If reduced under zero > return remaining pixels\n    else if (tempPixelSize < 0) {\n      return {\n        areaSnapshot,\n        pixelAbsorb: -areaSnapshot.sizePixelAtStart,\n        percentAfterAbsorption: -1,\n        pixelRemain: pixels + areaSnapshot.sizePixelAtStart\n      };\n    }\n    return {\n      areaSnapshot,\n      pixelAbsorb: pixels,\n      percentAfterAbsorption: -1,\n      pixelRemain: 0\n    };\n  }\n}\nfunction updateAreaSize(unit, item) {\n  if (unit === 'percent') {\n    item.areaSnapshot.area.size = item.percentAfterAbsorption;\n  } else if (unit === 'pixel') {\n    // Update size except for the wildcard size area\n    if (item.areaSnapshot.area.size !== null) {\n      item.areaSnapshot.area.size = item.areaSnapshot.sizePixelAtStart + item.pixelAbsorb;\n    }\n  }\n}\nconst ANGULAR_SPLIT_DEFAULT_OPTIONS = new InjectionToken('angular-split-global-config');\n\n/**\n * angular-split\n *\n *\n *  PERCENT MODE ([unit]=\"'percent'\")\n *  ___________________________________________________________________________________________\n * |       A       [g1]       B       [g2]       C       [g3]       D       [g4]       E       |\n * |-------------------------------------------------------------------------------------------|\n * |       20                 30                 20                 15                 15      | <-- [size]=\"x\"\n * |               10px               10px               10px               10px               | <-- [gutterSize]=\"10\"\n * |calc(20% - 8px)    calc(30% - 12px)   calc(20% - 8px)    calc(15% - 6px)    calc(15% - 6px)| <-- CSS flex-basis property (with flex-grow&shrink at 0)\n * |     152px              228px              152px              114px              114px     | <-- el.getBoundingClientRect().width\n * |___________________________________________________________________________________________|\n *                                                                                 800px         <-- el.getBoundingClientRect().width\n *  flex-basis = calc( { area.size }% - { area.size/100 * nbGutter*gutterSize }px );\n *\n *\n *  PIXEL MODE ([unit]=\"'pixel'\")\n *  ___________________________________________________________________________________________\n * |       A       [g1]       B       [g2]       C       [g3]       D       [g4]       E       |\n * |-------------------------------------------------------------------------------------------|\n * |      100                250                 *                 150                100      | <-- [size]=\"y\"\n * |               10px               10px               10px               10px               | <-- [gutterSize]=\"10\"\n * |   0 0 100px          0 0 250px           1 1 auto          0 0 150px          0 0 100px   | <-- CSS flex property (flex-grow/flex-shrink/flex-basis)\n * |     100px              250px              200px              150px              100px     | <-- el.getBoundingClientRect().width\n * |___________________________________________________________________________________________|\n *                                                                                 800px         <-- el.getBoundingClientRect().width\n *\n */\nlet SplitComponent = /*#__PURE__*/(() => {\n  class SplitComponent {\n    constructor(ngZone, elRef, cdRef, renderer, globalConfig) {\n      this.ngZone = ngZone;\n      this.elRef = elRef;\n      this.cdRef = cdRef;\n      this.renderer = renderer;\n      this.gutterClickDeltaPx = 2;\n      this._config = {\n        direction: 'horizontal',\n        unit: 'percent',\n        gutterSize: 11,\n        gutterStep: 1,\n        restrictMove: false,\n        useTransition: false,\n        disabled: false,\n        dir: 'ltr',\n        gutterDblClickDuration: 0\n      };\n      this.dragStart = new EventEmitter(false);\n      this.dragEnd = new EventEmitter(false);\n      this.gutterClick = new EventEmitter(false);\n      this.gutterDblClick = new EventEmitter(false);\n      this.dragProgressSubject = new Subject();\n      this.dragProgress$ = this.dragProgressSubject.asObservable();\n      this.isDragging = false;\n      this.isWaitingClear = false;\n      this.isWaitingInitialMove = false;\n      this.dragListeners = [];\n      this.snapshot = null;\n      this.startPoint = null;\n      this.endPoint = null;\n      this.displayedAreas = [];\n      this.hiddenAreas = [];\n      this._clickTimeout = null;\n      // To force adding default class, could be override by user @Input() or not\n      this.direction = this._direction;\n      this._config = globalConfig ? Object.assign(this._config, globalConfig) : this._config;\n      Object.keys(this._config).forEach(property => {\n        this[property] = this._config[property];\n      });\n    }\n    set direction(v) {\n      this._direction = v === 'vertical' ? 'vertical' : 'horizontal';\n      this.renderer.addClass(this.elRef.nativeElement, `as-${this._direction}`);\n      this.renderer.removeClass(this.elRef.nativeElement, `as-${this._direction === 'vertical' ? 'horizontal' : 'vertical'}`);\n      this.build(false, false);\n    }\n    get direction() {\n      return this._direction;\n    }\n    set unit(v) {\n      this._unit = v === 'pixel' ? 'pixel' : 'percent';\n      this.renderer.addClass(this.elRef.nativeElement, `as-${this._unit}`);\n      this.renderer.removeClass(this.elRef.nativeElement, `as-${this._unit === 'pixel' ? 'percent' : 'pixel'}`);\n      this.build(false, true);\n    }\n    get unit() {\n      return this._unit;\n    }\n    set gutterSize(v) {\n      this._gutterSize = getInputPositiveNumber(v, 11);\n      this.build(false, false);\n    }\n    get gutterSize() {\n      return this._gutterSize;\n    }\n    set gutterStep(v) {\n      this._gutterStep = getInputPositiveNumber(v, 1);\n    }\n    get gutterStep() {\n      return this._gutterStep;\n    }\n    set restrictMove(v) {\n      this._restrictMove = getInputBoolean(v);\n    }\n    get restrictMove() {\n      return this._restrictMove;\n    }\n    set useTransition(v) {\n      this._useTransition = getInputBoolean(v);\n      if (this._useTransition) {\n        this.renderer.addClass(this.elRef.nativeElement, 'as-transition');\n      } else {\n        this.renderer.removeClass(this.elRef.nativeElement, 'as-transition');\n      }\n    }\n    get useTransition() {\n      return this._useTransition;\n    }\n    set disabled(v) {\n      this._disabled = getInputBoolean(v);\n      if (this._disabled) {\n        this.renderer.addClass(this.elRef.nativeElement, 'as-disabled');\n      } else {\n        this.renderer.removeClass(this.elRef.nativeElement, 'as-disabled');\n      }\n    }\n    get disabled() {\n      return this._disabled;\n    }\n    set dir(v) {\n      this._dir = v === 'rtl' ? 'rtl' : 'ltr';\n      this.renderer.setAttribute(this.elRef.nativeElement, 'dir', this._dir);\n    }\n    get dir() {\n      return this._dir;\n    }\n    set gutterDblClickDuration(v) {\n      this._gutterDblClickDuration = getInputPositiveNumber(v, 0);\n    }\n    get gutterDblClickDuration() {\n      return this._gutterDblClickDuration;\n    }\n    get transitionEnd() {\n      return new Observable(subscriber => this.transitionEndSubscriber = subscriber).pipe(debounceTime(20));\n    }\n    ngAfterViewInit() {\n      this.ngZone.runOutsideAngular(() => {\n        // To avoid transition at first rendering\n        setTimeout(() => this.renderer.addClass(this.elRef.nativeElement, 'as-init'));\n      });\n    }\n    getNbGutters() {\n      return this.displayedAreas.length === 0 ? 0 : this.displayedAreas.length - 1;\n    }\n    addArea(component) {\n      const newArea = {\n        component,\n        order: 0,\n        size: 0,\n        minSize: null,\n        maxSize: null,\n        sizeBeforeCollapse: null,\n        gutterBeforeCollapse: 0\n      };\n      if (component.visible === true) {\n        this.displayedAreas.push(newArea);\n        this.build(true, true);\n      } else {\n        this.hiddenAreas.push(newArea);\n      }\n    }\n    removeArea(component) {\n      if (this.displayedAreas.some(a => a.component === component)) {\n        const area = this.displayedAreas.find(a => a.component === component);\n        this.displayedAreas.splice(this.displayedAreas.indexOf(area), 1);\n        this.build(true, true);\n      } else if (this.hiddenAreas.some(a => a.component === component)) {\n        const area = this.hiddenAreas.find(a => a.component === component);\n        this.hiddenAreas.splice(this.hiddenAreas.indexOf(area), 1);\n      }\n    }\n    updateArea(component, resetOrders, resetSizes) {\n      if (component.visible === true) {\n        this.build(resetOrders, resetSizes);\n      }\n    }\n    showArea(component) {\n      const area = this.hiddenAreas.find(a => a.component === component);\n      if (area === undefined) {\n        return;\n      }\n      const areas = this.hiddenAreas.splice(this.hiddenAreas.indexOf(area), 1);\n      this.displayedAreas.push(...areas);\n      this.build(true, true);\n    }\n    hideArea(comp) {\n      const area = this.displayedAreas.find(a => a.component === comp);\n      if (area === undefined) {\n        return;\n      }\n      const areas = this.displayedAreas.splice(this.displayedAreas.indexOf(area), 1);\n      areas.forEach(item => {\n        item.order = 0;\n        item.size = 0;\n      });\n      this.hiddenAreas.push(...areas);\n      this.build(true, true);\n    }\n    getVisibleAreaSizes() {\n      return this.displayedAreas.map(a => a.size === null ? '*' : a.size);\n    }\n    setVisibleAreaSizes(sizes) {\n      if (sizes.length !== this.displayedAreas.length) {\n        return false;\n      }\n      const formattedSizes = sizes.map(s => getInputPositiveNumber(s, null));\n      const isValid = isUserSizesValid(this.unit, formattedSizes);\n      if (isValid === false) {\n        return false;\n      }\n      // @ts-ignore\n      this.displayedAreas.forEach((area, i) => area.component._size = formattedSizes[i]);\n      this.build(false, true);\n      return true;\n    }\n    build(resetOrders, resetSizes) {\n      this.stopDragging();\n      // ¤ AREAS ORDER\n      if (resetOrders === true) {\n        // If user provided 'order' for each area, use it to sort them.\n        if (this.displayedAreas.every(a => a.component.order !== null)) {\n          this.displayedAreas.sort((a, b) => a.component.order - b.component.order);\n        }\n        // Then set real order with multiples of 2, numbers between will be used by gutters.\n        this.displayedAreas.forEach((area, i) => {\n          area.order = i * 2;\n          area.component.setStyleOrder(area.order);\n        });\n      }\n      // ¤ AREAS SIZE\n      if (resetSizes === true) {\n        const useUserSizes = isUserSizesValid(this.unit, this.displayedAreas.map(a => a.component.size));\n        switch (this.unit) {\n          case 'percent':\n            {\n              const defaultSize = 100 / this.displayedAreas.length;\n              this.displayedAreas.forEach(area => {\n                area.size = useUserSizes ? area.component.size : defaultSize;\n                area.minSize = getAreaMinSize(area);\n                area.maxSize = getAreaMaxSize(area);\n              });\n              break;\n            }\n          case 'pixel':\n            {\n              if (useUserSizes) {\n                this.displayedAreas.forEach(area => {\n                  area.size = area.component.size;\n                  area.minSize = getAreaMinSize(area);\n                  area.maxSize = getAreaMaxSize(area);\n                });\n              } else {\n                const wildcardSizeAreas = this.displayedAreas.filter(a => a.component.size === null);\n                // No wildcard area > Need to select one arbitrarily > first\n                if (wildcardSizeAreas.length === 0 && this.displayedAreas.length > 0) {\n                  this.displayedAreas.forEach((area, i) => {\n                    area.size = i === 0 ? null : area.component.size;\n                    area.minSize = i === 0 ? null : getAreaMinSize(area);\n                    area.maxSize = i === 0 ? null : getAreaMaxSize(area);\n                  });\n                } else if (wildcardSizeAreas.length > 1) {\n                  // More than one wildcard area > Need to keep only one arbitrarily > first\n                  let alreadyGotOne = false;\n                  this.displayedAreas.forEach(area => {\n                    if (area.component.size === null) {\n                      if (alreadyGotOne === false) {\n                        area.size = null;\n                        area.minSize = null;\n                        area.maxSize = null;\n                        alreadyGotOne = true;\n                      } else {\n                        area.size = 100;\n                        area.minSize = null;\n                        area.maxSize = null;\n                      }\n                    } else {\n                      area.size = area.component.size;\n                      area.minSize = getAreaMinSize(area);\n                      area.maxSize = getAreaMaxSize(area);\n                    }\n                  });\n                }\n              }\n              break;\n            }\n        }\n      }\n      this.refreshStyleSizes();\n      this.cdRef.markForCheck();\n    }\n    refreshStyleSizes() {\n      ///////////////////////////////////////////\n      // PERCENT MODE\n      if (this.unit === 'percent') {\n        // Only one area > flex-basis 100%\n        if (this.displayedAreas.length === 1) {\n          this.displayedAreas[0].component.setStyleFlex(0, 0, `100%`, false, false);\n        } else {\n          // Multiple areas > use each percent basis\n          const sumGutterSize = this.getNbGutters() * this.gutterSize;\n          this.displayedAreas.forEach(area => {\n            area.component.setStyleFlex(0, 0, `calc( ${area.size}% - ${area.size / 100 * sumGutterSize}px )`, area.minSize !== null && area.minSize === area.size, area.maxSize !== null && area.maxSize === area.size);\n          });\n        }\n      } else if (this.unit === 'pixel') {\n        ///////////////////////////////////////////\n        // PIXEL MODE\n        this.displayedAreas.forEach(area => {\n          // Area with wildcard size\n          if (area.size === null) {\n            if (this.displayedAreas.length === 1) {\n              area.component.setStyleFlex(1, 1, `100%`, false, false);\n            } else {\n              area.component.setStyleFlex(1, 1, `auto`, false, false);\n            }\n          } else {\n            // Area with pixel size\n            // Only one area > flex-basis 100%\n            if (this.displayedAreas.length === 1) {\n              area.component.setStyleFlex(0, 0, `100%`, false, false);\n            } else {\n              // Multiple areas > use each pixel basis\n              area.component.setStyleFlex(0, 0, `${area.size}px`, area.minSize !== null && area.minSize === area.size, area.maxSize !== null && area.maxSize === area.size);\n            }\n          }\n        });\n      }\n    }\n    clickGutter(event, gutterNum) {\n      const tempPoint = getPointFromEvent(event);\n      // Be sure mouseup/touchend happened if touch/cursor is not moved.\n      if (this.startPoint && pointDeltaEquals(this.startPoint, tempPoint, this.gutterClickDeltaPx) && (!this.isDragging || this.isWaitingInitialMove)) {\n        // If timeout in progress and new click > clearTimeout & dblClickEvent\n        if (this._clickTimeout !== null) {\n          window.clearTimeout(this._clickTimeout);\n          this._clickTimeout = null;\n          this.notify('dblclick', gutterNum);\n          this.stopDragging();\n        } else {\n          // Else start timeout to call clickEvent at end\n          this._clickTimeout = window.setTimeout(() => {\n            this._clickTimeout = null;\n            this.notify('click', gutterNum);\n            this.stopDragging();\n          }, this.gutterDblClickDuration);\n        }\n      }\n    }\n    startKeyboardDrag(event, gutterOrder, gutterNum) {\n      if (this.disabled === true || this.isWaitingClear === true) {\n        return;\n      }\n      const endPoint = getKeyboardEndpoint(event, this.direction);\n      if (endPoint === null) {\n        return;\n      }\n      this.endPoint = endPoint;\n      this.startPoint = getPointFromEvent(event);\n      event.preventDefault();\n      event.stopPropagation();\n      this.setupForDragEvent(gutterOrder, gutterNum);\n      this.startDragging();\n      this.drag();\n      this.stopDragging();\n    }\n    startMouseDrag(event, gutterOrder, gutterNum) {\n      event.preventDefault();\n      event.stopPropagation();\n      this.startPoint = getPointFromEvent(event);\n      if (this.startPoint === null || this.disabled === true || this.isWaitingClear === true) {\n        return;\n      }\n      this.setupForDragEvent(gutterOrder, gutterNum);\n      this.dragListeners.push(this.renderer.listen('document', 'mouseup', this.stopDragging.bind(this)));\n      this.dragListeners.push(this.renderer.listen('document', 'touchend', this.stopDragging.bind(this)));\n      this.dragListeners.push(this.renderer.listen('document', 'touchcancel', this.stopDragging.bind(this)));\n      this.ngZone.runOutsideAngular(() => {\n        this.dragListeners.push(this.renderer.listen('document', 'mousemove', this.mouseDragEvent.bind(this)));\n        this.dragListeners.push(this.renderer.listen('document', 'touchmove', this.mouseDragEvent.bind(this)));\n      });\n      this.startDragging();\n    }\n    setupForDragEvent(gutterOrder, gutterNum) {\n      this.snapshot = {\n        gutterNum,\n        lastSteppedOffset: 0,\n        allAreasSizePixel: getElementPixelSize(this.elRef, this.direction) - this.getNbGutters() * this.gutterSize,\n        allInvolvedAreasSizePercent: 100,\n        areasBeforeGutter: [],\n        areasAfterGutter: []\n      };\n      this.displayedAreas.forEach(area => {\n        const areaSnapshot = {\n          area,\n          sizePixelAtStart: getElementPixelSize(area.component.elRef, this.direction),\n          sizePercentAtStart: this.unit === 'percent' ? area.size : -1 // If pixel mode, anyway, will not be used.\n        };\n        if (area.order < gutterOrder) {\n          if (this.restrictMove === true) {\n            this.snapshot.areasBeforeGutter = [areaSnapshot];\n          } else {\n            this.snapshot.areasBeforeGutter.unshift(areaSnapshot);\n          }\n        } else if (area.order > gutterOrder) {\n          if (this.restrictMove === true) {\n            if (this.snapshot.areasAfterGutter.length === 0) {\n              this.snapshot.areasAfterGutter = [areaSnapshot];\n            }\n          } else {\n            this.snapshot.areasAfterGutter.push(areaSnapshot);\n          }\n        }\n      });\n      this.snapshot.allInvolvedAreasSizePercent = [...this.snapshot.areasBeforeGutter, ...this.snapshot.areasAfterGutter].reduce((t, a) => t + a.sizePercentAtStart, 0);\n      if (this.snapshot.areasBeforeGutter.length === 0 || this.snapshot.areasAfterGutter.length === 0) {\n        return;\n      }\n    }\n    startDragging() {\n      this.displayedAreas.forEach(area => area.component.lockEvents());\n      this.isDragging = true;\n      this.isWaitingInitialMove = true;\n    }\n    mouseDragEvent(event) {\n      event.preventDefault();\n      event.stopPropagation();\n      const tempPoint = getPointFromEvent(event);\n      if (this._clickTimeout !== null && !pointDeltaEquals(this.startPoint, tempPoint, this.gutterClickDeltaPx)) {\n        window.clearTimeout(this._clickTimeout);\n        this._clickTimeout = null;\n      }\n      if (this.isDragging === false) {\n        return;\n      }\n      this.endPoint = getPointFromEvent(event);\n      if (this.endPoint === null) {\n        return;\n      }\n      this.drag();\n    }\n    drag() {\n      if (this.isWaitingInitialMove) {\n        if (this.startPoint.x !== this.endPoint.x || this.startPoint.y !== this.endPoint.y) {\n          this.ngZone.run(() => {\n            this.isWaitingInitialMove = false;\n            this.renderer.addClass(this.elRef.nativeElement, 'as-dragging');\n            this.renderer.addClass(this.gutterEls.toArray()[this.snapshot.gutterNum - 1].nativeElement, 'as-dragged');\n            this.notify('start', this.snapshot.gutterNum);\n          });\n        } else {\n          return;\n        }\n      }\n      // Calculate steppedOffset\n      let offset = this.direction === 'horizontal' ? this.startPoint.x - this.endPoint.x : this.startPoint.y - this.endPoint.y;\n      if (this.dir === 'rtl') {\n        offset = -offset;\n      }\n      const steppedOffset = Math.round(offset / this.gutterStep) * this.gutterStep;\n      if (steppedOffset === this.snapshot.lastSteppedOffset) {\n        return;\n      }\n      this.snapshot.lastSteppedOffset = steppedOffset;\n      // Need to know if each gutter side areas could reacts to steppedOffset\n      let areasBefore = getGutterSideAbsorptionCapacity(this.unit, this.snapshot.areasBeforeGutter, -steppedOffset, this.snapshot.allAreasSizePixel);\n      let areasAfter = getGutterSideAbsorptionCapacity(this.unit, this.snapshot.areasAfterGutter, steppedOffset, this.snapshot.allAreasSizePixel);\n      // Each gutter side areas can't absorb all offset\n      if (areasBefore.remain !== 0 && areasAfter.remain !== 0) {\n        if (Math.abs(areasBefore.remain) === Math.abs(areasAfter.remain)) {} else if (Math.abs(areasBefore.remain) > Math.abs(areasAfter.remain)) {\n          areasAfter = getGutterSideAbsorptionCapacity(this.unit, this.snapshot.areasAfterGutter, steppedOffset + areasBefore.remain, this.snapshot.allAreasSizePixel);\n        } else {\n          areasBefore = getGutterSideAbsorptionCapacity(this.unit, this.snapshot.areasBeforeGutter, -(steppedOffset - areasAfter.remain), this.snapshot.allAreasSizePixel);\n        }\n      } else if (areasBefore.remain !== 0) {\n        // Areas before gutter can't absorbs all offset > need to recalculate sizes for areas after gutter.\n        areasAfter = getGutterSideAbsorptionCapacity(this.unit, this.snapshot.areasAfterGutter, steppedOffset + areasBefore.remain, this.snapshot.allAreasSizePixel);\n      } else if (areasAfter.remain !== 0) {\n        // Areas after gutter can't absorbs all offset > need to recalculate sizes for areas before gutter.\n        areasBefore = getGutterSideAbsorptionCapacity(this.unit, this.snapshot.areasBeforeGutter, -(steppedOffset - areasAfter.remain), this.snapshot.allAreasSizePixel);\n      }\n      if (this.unit === 'percent') {\n        // Hack because of browser messing up with sizes using calc(X% - Ypx) -> el.getBoundingClientRect()\n        // If not there, playing with gutters makes total going down to 99.99875% then 99.99286%, 99.98986%,..\n        const all = [...areasBefore.list, ...areasAfter.list];\n        const areaToReset = all.find(a => a.percentAfterAbsorption !== 0 && a.percentAfterAbsorption !== a.areaSnapshot.area.minSize && a.percentAfterAbsorption !== a.areaSnapshot.area.maxSize);\n        if (areaToReset) {\n          areaToReset.percentAfterAbsorption = this.snapshot.allInvolvedAreasSizePercent - all.filter(a => a !== areaToReset).reduce((total, a) => total + a.percentAfterAbsorption, 0);\n        }\n      }\n      // Now we know areas could absorb steppedOffset, time to really update sizes\n      areasBefore.list.forEach(item => updateAreaSize(this.unit, item));\n      areasAfter.list.forEach(item => updateAreaSize(this.unit, item));\n      this.refreshStyleSizes();\n      this.notify('progress', this.snapshot.gutterNum);\n    }\n    stopDragging(event) {\n      if (event) {\n        event.preventDefault();\n        event.stopPropagation();\n      }\n      if (this.isDragging === false) {\n        return;\n      }\n      this.displayedAreas.forEach(area => area.component.unlockEvents());\n      while (this.dragListeners.length > 0) {\n        const fct = this.dragListeners.pop();\n        if (fct) {\n          fct();\n        }\n      }\n      // Warning: Have to be before \"notify('end')\"\n      // because \"notify('end')\"\" can be linked to \"[size]='x'\" > \"build()\" > \"stopDragging()\"\n      this.isDragging = false;\n      // If moved from starting point, notify end\n      if (this.isWaitingInitialMove === false) {\n        this.notify('end', this.snapshot.gutterNum);\n      }\n      this.renderer.removeClass(this.elRef.nativeElement, 'as-dragging');\n      this.renderer.removeClass(this.gutterEls.toArray()[this.snapshot.gutterNum - 1].nativeElement, 'as-dragged');\n      this.snapshot = null;\n      this.isWaitingClear = true;\n      // Needed to let (click)=\"clickGutter(...)\" event run and verify if mouse moved or not\n      this.ngZone.runOutsideAngular(() => {\n        setTimeout(() => {\n          this.startPoint = null;\n          this.endPoint = null;\n          this.isWaitingClear = false;\n        });\n      });\n    }\n    notify(type, gutterNum) {\n      const sizes = this.getVisibleAreaSizes();\n      if (type === 'start') {\n        this.dragStart.emit({\n          gutterNum,\n          sizes\n        });\n      } else if (type === 'end') {\n        this.dragEnd.emit({\n          gutterNum,\n          sizes\n        });\n      } else if (type === 'click') {\n        this.gutterClick.emit({\n          gutterNum,\n          sizes\n        });\n      } else if (type === 'dblclick') {\n        this.gutterDblClick.emit({\n          gutterNum,\n          sizes\n        });\n      } else if (type === 'transitionEnd') {\n        if (this.transitionEndSubscriber) {\n          this.ngZone.run(() => this.transitionEndSubscriber.next(sizes));\n        }\n      } else if (type === 'progress') {\n        // Stay outside zone to allow users do what they want about change detection mechanism.\n        this.dragProgressSubject.next({\n          gutterNum,\n          sizes\n        });\n      }\n    }\n    ngOnDestroy() {\n      this.stopDragging();\n    }\n    collapseArea(comp, newSize, gutter) {\n      const area = this.displayedAreas.find(a => a.component === comp);\n      if (area === undefined) {\n        return;\n      }\n      const whichGutter = gutter === 'right' ? 1 : -1;\n      if (!area.sizeBeforeCollapse) {\n        area.sizeBeforeCollapse = area.size;\n        area.gutterBeforeCollapse = whichGutter;\n      }\n      area.size = newSize;\n      const gtr = this.gutterEls.find(f => f.nativeElement.style.order === `${area.order + whichGutter}`);\n      if (gtr) {\n        this.renderer.addClass(gtr.nativeElement, 'as-split-gutter-collapsed');\n      }\n      this.updateArea(comp, false, false);\n    }\n    expandArea(comp) {\n      const area = this.displayedAreas.find(a => a.component === comp);\n      if (area === undefined) {\n        return;\n      }\n      if (!area.sizeBeforeCollapse) {\n        return;\n      }\n      area.size = area.sizeBeforeCollapse;\n      area.sizeBeforeCollapse = null;\n      const gtr = this.gutterEls.find(f => f.nativeElement.style.order === `${area.order + area.gutterBeforeCollapse}`);\n      if (gtr) {\n        this.renderer.removeClass(gtr.nativeElement, 'as-split-gutter-collapsed');\n      }\n      this.updateArea(comp, false, false);\n    }\n    getAriaAreaSizeText(size) {\n      if (size === null) {\n        return null;\n      }\n      return size.toFixed(0) + ' ' + this.unit;\n    }\n  }\n  /** @nocollapse */ /** @nocollapse */\n  /** @nocollapse */ /** @nocollapse */SplitComponent.ɵfac = function SplitComponent_Factory(t) {\n    return new (t || SplitComponent)(i0.ɵɵdirectiveInject(i0.NgZone), i0.ɵɵdirectiveInject(i0.ElementRef), i0.ɵɵdirectiveInject(i0.ChangeDetectorRef), i0.ɵɵdirectiveInject(i0.Renderer2), i0.ɵɵdirectiveInject(ANGULAR_SPLIT_DEFAULT_OPTIONS, 8));\n  };\n  SplitComponent.ɵcmp = /* @__PURE__ */i0.ɵɵdefineComponent({\n    type: SplitComponent,\n    selectors: [[\"as-split\"]],\n    viewQuery: function SplitComponent_Query(rf, ctx) {\n      if (rf & 1) {\n        i0.ɵɵviewQuery(_c0, 5);\n      }\n      if (rf & 2) {\n        let _t;\n        i0.ɵɵqueryRefresh(_t = i0.ɵɵloadQuery()) && (ctx.gutterEls = _t);\n      }\n    },\n    inputs: {\n      direction: \"direction\",\n      unit: \"unit\",\n      gutterSize: \"gutterSize\",\n      gutterStep: \"gutterStep\",\n      restrictMove: \"restrictMove\",\n      useTransition: \"useTransition\",\n      disabled: \"disabled\",\n      dir: \"dir\",\n      gutterDblClickDuration: \"gutterDblClickDuration\",\n      gutterClickDeltaPx: \"gutterClickDeltaPx\",\n      gutterAriaLabel: \"gutterAriaLabel\"\n    },\n    outputs: {\n      transitionEnd: \"transitionEnd\",\n      dragStart: \"dragStart\",\n      dragEnd: \"dragEnd\",\n      gutterClick: \"gutterClick\",\n      gutterDblClick: \"gutterDblClick\"\n    },\n    exportAs: [\"asSplit\"],\n    ngContentSelectors: _c1,\n    decls: 2,\n    vars: 1,\n    consts: [[\"ngFor\", \"\", 3, \"ngForOf\"], [\"role\", \"slider\", \"tabindex\", \"0\", \"class\", \"as-split-gutter\", 3, \"flex-basis\", \"order\", \"keydown\", \"mousedown\", \"touchstart\", \"mouseup\", \"touchend\", 4, \"ngIf\"], [\"role\", \"slider\", \"tabindex\", \"0\", 1, \"as-split-gutter\", 3, \"keydown\", \"mousedown\", \"touchstart\", \"mouseup\", \"touchend\"], [\"gutterEls\", \"\"], [1, \"as-split-gutter-icon\"]],\n    template: function SplitComponent_Template(rf, ctx) {\n      if (rf & 1) {\n        i0.ɵɵprojectionDef();\n        i0.ɵɵprojection(0);\n        i0.ɵɵtemplate(1, SplitComponent_ng_template_1_Template, 1, 1, \"ng-template\", 0);\n      }\n      if (rf & 2) {\n        i0.ɵɵadvance(1);\n        i0.ɵɵproperty(\"ngForOf\", ctx.displayedAreas);\n      }\n    },\n    dependencies: [i1.NgForOf, i1.NgIf],\n    styles: [\"[_nghost-%COMP%]{display:flex;flex-wrap:nowrap;justify-content:flex-start;align-items:stretch;overflow:hidden;width:100%;height:100%}[_nghost-%COMP%] > .as-split-gutter[_ngcontent-%COMP%]{border:none;flex-grow:0;flex-shrink:0;background-color:#eee;display:flex;align-items:center;justify-content:center}[_nghost-%COMP%] > .as-split-gutter.as-split-gutter-collapsed[_ngcontent-%COMP%]{flex-basis:1px!important;pointer-events:none}[_nghost-%COMP%] > .as-split-gutter[_ngcontent-%COMP%] > .as-split-gutter-icon[_ngcontent-%COMP%]{width:100%;height:100%;background-position:center center;background-repeat:no-repeat}[_nghost-%COMP%]    >.as-split-area{flex-grow:0;flex-shrink:0;overflow-x:hidden;overflow-y:auto}[_nghost-%COMP%]    >.as-split-area.as-hidden{flex:0 1 0px!important;overflow-x:hidden;overflow-y:hidden}.as-horizontal[_nghost-%COMP%]{flex-direction:row}.as-horizontal[_nghost-%COMP%] > .as-split-gutter[_ngcontent-%COMP%]{flex-direction:row;cursor:col-resize;height:100%}.as-horizontal[_nghost-%COMP%] > .as-split-gutter[_ngcontent-%COMP%] > .as-split-gutter-icon[_ngcontent-%COMP%]{background-image:url(data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAAAUAAAAeCAYAAADkftS9AAAAIklEQVQoU2M4c+bMfxAGAgYYmwGrIIiDjrELjpo5aiZeMwF+yNnOs5KSvgAAAABJRU5ErkJggg==)}.as-horizontal[_nghost-%COMP%]    >.as-split-area{height:100%}.as-vertical[_nghost-%COMP%]{flex-direction:column}.as-vertical[_nghost-%COMP%] > .as-split-gutter[_ngcontent-%COMP%]{flex-direction:column;cursor:row-resize;width:100%}.as-vertical[_nghost-%COMP%] > .as-split-gutter[_ngcontent-%COMP%]   .as-split-gutter-icon[_ngcontent-%COMP%]{background-image:url(data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAAB4AAAAFCAMAAABl/6zIAAAABlBMVEUAAADMzMzIT8AyAAAAAXRSTlMAQObYZgAAABRJREFUeAFjYGRkwIMJSeMHlBkOABP7AEGzSuPKAAAAAElFTkSuQmCC)}.as-vertical[_nghost-%COMP%]    >.as-split-area{width:100%}.as-vertical[_nghost-%COMP%]    >.as-split-area.as-hidden{max-width:0}.as-disabled[_nghost-%COMP%] > .as-split-gutter[_ngcontent-%COMP%]{cursor:default}.as-disabled[_nghost-%COMP%] > .as-split-gutter[_ngcontent-%COMP%]   .as-split-gutter-icon[_ngcontent-%COMP%]{background-image:url()}.as-transition.as-init[_nghost-%COMP%]:not(.as-dragging) > .as-split-gutter[_ngcontent-%COMP%], .as-transition.as-init[_nghost-%COMP%]:not(.as-dragging)    >.as-split-area{transition:flex-basis .3s}\"],\n    changeDetection: 0\n  });\n  return SplitComponent;\n})();\n(function () {\n  (typeof ngDevMode === \"undefined\" || ngDevMode) && void 0;\n})();\nlet SplitAreaDirective = /*#__PURE__*/(() => {\n  class SplitAreaDirective {\n    constructor(ngZone, elRef, renderer, split) {\n      this.ngZone = ngZone;\n      this.elRef = elRef;\n      this.renderer = renderer;\n      this.split = split;\n      this._order = null;\n      this._size = null;\n      this._minSize = null;\n      this._maxSize = null;\n      this._lockSize = false;\n      this._visible = true;\n      this.lockListeners = [];\n      this.renderer.addClass(this.elRef.nativeElement, 'as-split-area');\n    }\n    set order(v) {\n      this._order = getInputPositiveNumber(v, null);\n      this.split.updateArea(this, true, false);\n    }\n    get order() {\n      return this._order;\n    }\n    set size(v) {\n      this._size = getInputPositiveNumber(v, null);\n      this.split.updateArea(this, false, true);\n    }\n    get size() {\n      return this._size;\n    }\n    set minSize(v) {\n      this._minSize = getInputPositiveNumber(v, null);\n      this.split.updateArea(this, false, true);\n    }\n    get minSize() {\n      return this._minSize;\n    }\n    set maxSize(v) {\n      this._maxSize = getInputPositiveNumber(v, null);\n      this.split.updateArea(this, false, true);\n    }\n    get maxSize() {\n      return this._maxSize;\n    }\n    set lockSize(v) {\n      this._lockSize = getInputBoolean(v);\n      this.split.updateArea(this, false, true);\n    }\n    get lockSize() {\n      return this._lockSize;\n    }\n    set visible(v) {\n      this._visible = getInputBoolean(v);\n      if (this._visible) {\n        this.split.showArea(this);\n        this.renderer.removeClass(this.elRef.nativeElement, 'as-hidden');\n      } else {\n        this.split.hideArea(this);\n        this.renderer.addClass(this.elRef.nativeElement, 'as-hidden');\n      }\n    }\n    get visible() {\n      return this._visible;\n    }\n    ngOnInit() {\n      this.split.addArea(this);\n      this.ngZone.runOutsideAngular(() => {\n        this.transitionListener = this.renderer.listen(this.elRef.nativeElement, 'transitionend', event => {\n          // Limit only flex-basis transition to trigger the event\n          if (event.propertyName === 'flex-basis') {\n            this.split.notify('transitionEnd', -1);\n          }\n        });\n      });\n    }\n    setStyleOrder(value) {\n      this.renderer.setStyle(this.elRef.nativeElement, 'order', value);\n    }\n    setStyleFlex(grow, shrink, basis, isMin, isMax) {\n      // Need 3 separated properties to work on IE11 (https://github.com/angular/flex-layout/issues/323)\n      this.renderer.setStyle(this.elRef.nativeElement, 'flex-grow', grow);\n      this.renderer.setStyle(this.elRef.nativeElement, 'flex-shrink', shrink);\n      this.renderer.setStyle(this.elRef.nativeElement, 'flex-basis', basis);\n      if (isMin === true) {\n        this.renderer.addClass(this.elRef.nativeElement, 'as-min');\n      } else {\n        this.renderer.removeClass(this.elRef.nativeElement, 'as-min');\n      }\n      if (isMax === true) {\n        this.renderer.addClass(this.elRef.nativeElement, 'as-max');\n      } else {\n        this.renderer.removeClass(this.elRef.nativeElement, 'as-max');\n      }\n    }\n    lockEvents() {\n      this.ngZone.runOutsideAngular(() => {\n        this.lockListeners.push(this.renderer.listen(this.elRef.nativeElement, 'selectstart', () => false));\n        this.lockListeners.push(this.renderer.listen(this.elRef.nativeElement, 'dragstart', () => false));\n      });\n    }\n    unlockEvents() {\n      while (this.lockListeners.length > 0) {\n        const fct = this.lockListeners.pop();\n        if (fct) {\n          fct();\n        }\n      }\n    }\n    ngOnDestroy() {\n      this.unlockEvents();\n      if (this.transitionListener) {\n        this.transitionListener();\n      }\n      this.split.removeArea(this);\n    }\n    collapse(newSize = 0, gutter = 'right') {\n      this.split.collapseArea(this, newSize, gutter);\n    }\n    expand() {\n      this.split.expandArea(this);\n    }\n  }\n  /** @nocollapse */ /** @nocollapse */\n  /** @nocollapse */ /** @nocollapse */SplitAreaDirective.ɵfac = function SplitAreaDirective_Factory(t) {\n    return new (t || SplitAreaDirective)(i0.ɵɵdirectiveInject(i0.NgZone), i0.ɵɵdirectiveInject(i0.ElementRef), i0.ɵɵdirectiveInject(i0.Renderer2), i0.ɵɵdirectiveInject(SplitComponent));\n  };\n  SplitAreaDirective.ɵdir = /* @__PURE__ */i0.ɵɵdefineDirective({\n    type: SplitAreaDirective,\n    selectors: [[\"as-split-area\"], [\"\", \"as-split-area\", \"\"]],\n    inputs: {\n      order: \"order\",\n      size: \"size\",\n      minSize: \"minSize\",\n      maxSize: \"maxSize\",\n      lockSize: \"lockSize\",\n      visible: \"visible\"\n    },\n    exportAs: [\"asSplitArea\"]\n  });\n  return SplitAreaDirective;\n})();\n(function () {\n  (typeof ngDevMode === \"undefined\" || ngDevMode) && void 0;\n})();\nlet AngularSplitModule = /*#__PURE__*/(() => {\n  class AngularSplitModule {\n    static forRoot() {\n      console.warn(`AngularSplitModule.forRoot() is deprecated and will be removed in v6`);\n      return {\n        ngModule: AngularSplitModule,\n        providers: []\n      };\n    }\n    static forChild() {\n      console.warn(`AngularSplitModule.forChild() is deprecated and will be removed in v6`);\n      return {\n        ngModule: AngularSplitModule,\n        providers: []\n      };\n    }\n  }\n  /** @nocollapse */ /** @nocollapse */\n  /** @nocollapse */ /** @nocollapse */\n  /** @nocollapse */ /** @nocollapse */AngularSplitModule.ɵfac = function AngularSplitModule_Factory(t) {\n    return new (t || AngularSplitModule)();\n  };\n  AngularSplitModule.ɵmod = /* @__PURE__ */i0.ɵɵdefineNgModule({\n    type: AngularSplitModule\n  });\n  AngularSplitModule.ɵinj = /* @__PURE__ */i0.ɵɵdefineInjector({\n    imports: [[CommonModule]]\n  });\n  return AngularSplitModule;\n})();\n(function () {\n  (typeof ngDevMode === \"undefined\" || ngDevMode) && void 0;\n})();\n\n/*\n * Public API Surface of angular-split\n */\n\n/**\n * Generated bundle index. Do not edit.\n */\n\nexport { ANGULAR_SPLIT_DEFAULT_OPTIONS, AngularSplitModule, SplitAreaDirective, SplitComponent };","map":null,"metadata":{},"sourceType":"module","externalDependencies":[]}